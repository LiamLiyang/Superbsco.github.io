<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[2017-1-30：河内之塔]]></title>
      <url>%2F2017%2F01%2F30%2Fsf1%2F</url>
      <content type="text"><![CDATA[前言河内之塔(Towers of Hanoi)是法国人M.Claus(Lucas)于1883年从泰国带至法国的，河内为越战时北越的首都，即现在的胡志明市；1883年法国数学家Edouard Lucas曾提及这个故事，据说创世纪时Benares有一座波罗教塔，是由三支钻石棒（Pag）所支撑，开始时神在第一根棒上放置64个由上至下依由小至大排列的金盘（Disc），并命令僧侣将所有的金盘从第一根石棒移至第三根石棒，且搬运过程中遵守大盘子在小盘子之下的原则，若每日仅搬一个盘子，则当盘子全数搬运完毕之时，此塔将毁损，而也就是世界末日来临之时。我们来把这个故事变成一个算法： 把三个柱子标为ABC如果只有一个盘子时，将它直接搬到c；当有两个盘子：A-&gt;B A-&gt;C B-&gt;C这三个步骤，当有三个盘子时：A-&gt;C A-&gt;B C-&gt;B A-&gt;C B-&gt;A B-&gt;C A-&gt;C。如果有n个盘子，则移动完毕所需的次数为2^n-1。 C++算法代码123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;void hanoi(int n, char A, char B, char C)&#123; if (n == 1) &#123; cout &lt;&lt; " Move " &lt;&lt; n &lt;&lt; " from " &lt;&lt; A &lt;&lt; " to " &lt;&lt; C &lt;&lt; endl; &#125; else &#123; hanoi(n - 1, A, C, B); //把A柱子上第N-1个盘子通过C放到B柱子上 cout &lt;&lt; " Move " &lt;&lt; n &lt;&lt; " from " &lt;&lt; A &lt;&lt; " to " &lt;&lt; C &lt;&lt; endl; hanoi(n - 1, B, A, C); //把B上所有盘子通过A放到C上 &#125;&#125;int main()&#123; cout &lt;&lt; "请输入盘子数量：" &lt;&lt; endl; int n; cin &gt;&gt; n; hanoi(n, 'A', 'B', 'C'); return 0;&#125; 以n=3为例，解释hanoi(int n,char A,char B,char C)方法： 执行hanoi（2，A，C，B）-&gt;执行hanoi（1，A，C，B）输出：Move 1 from A to C n=2的时候执行完hanoi（2，A，C，B），执行cout &lt;&lt; “ Move “ &lt;&lt; n &lt;&lt; “ from “ &lt;&lt; A &lt;&lt; “ to “ &lt;&lt; C &lt;&lt; endl;输出：Move 2 from A to B 执行Hanoi(n - 1, B, A, C);这相当于Hanoi(1,C,A,B)相当于把C柱子上的1盘子放到B上，把A柱子上的最后一个盘子3放到C柱子上，输出：Move 1 from C to BMove 3 from A to C Hanoi(n - 1, B, A, C);上一个递归我们已经把n-1个盘子放到了B柱子上，这个方法就是把B柱子上的盘子放到C柱子上,也就是Hanoi(2,B,A,C)它再递归.先调用Hanoi(n - 1, A, C, B); 这个时候 的A是B B为C,C为A. 就是把B上的1盘子放到A柱子上,把B柱子上的2盘子放到C柱子上.输出：Move 1 from B to AMove 2 from B to C Hanoi(n - 1, B, A, C);也就是Hanoi(1,A,B,C);会把A柱子上的C盘子入到C柱子上去，输出：Move 1 from A to C总共7步。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[模拟银行ATM机]]></title>
      <url>%2F2017%2F01%2F28%2Fatmdemo%2F</url>
      <content type="text"><![CDATA[前言C++实践选的题目是模拟银行ATM的操作。JAVA实践的时候用NETBEANS 写成界面。 模拟银行ATM机查询余额：初始余额为10000元ATM取款：每次取款金额为100的倍数，总额不超过5000元，支取金额不允许透支。ATM存款：不能出现负存款。修改密码：新密码长度不小于6位，不允许出现6位完全相同的情况，只有旧密码正确，新密码符合要求，且两次输入相同的情况下才可以成功修改密码。 C++模拟银行ATM机代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245#include &lt;iostream&gt;#include &lt;string&gt; #include &lt;fstream&gt; //读写文件的头文件#include &lt;conio.h&gt; //使用该头文件调用函数getch（）可以不回显读取密码using namespace std;class BankAccount//登陆银行账户类&#123;private: string account,password; string account1,password1;public: BankAccount() &#123; ifstream fopen("D:\\inf.txt");//读取D盘inf.txt文件 if (!fopen) &#123; cout &lt;&lt; "fail to read the file.\n"; &#125; string line1,line3; while (!fopen.eof()) &#123; //读取D盘写入的文件 getline(fopen, line1); //读取第一行，下面以此类推 getline(fopen, account); getline(fopen, line3); getline(fopen, password); &#125; fopen.close(); cout &lt;&lt; "********************************************************************" &lt;&lt; endl;//进入ATM的初始界面 cout &lt;&lt; "****************$欢迎使用银行ATM自动取款机********************" &lt;&lt; endl; cout &lt;&lt; "********************************************************************" &lt;&lt; endl; cout &lt;&lt; "请输入您的银行卡号:"; cin &gt;&gt; account1; cout &lt;&lt; "请输入您的银行密码:"; char p[20],i=0; while(p[i]=_getch())//调用getch（）不回显获取密码 &#123; if (p[i]!='\r') &#123; cout &lt;&lt; "*"; i++; &#125; else &#123;break;&#125; &#125; p[i]='\0'; password1=p; if (account == account1 &amp;&amp; password == password1) &#123; cout &lt;&lt; endl; cout &lt;&lt; "登陆银行账户成功!" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "\n登陆银行账户失败，请检查您的账户密码是否正确" &lt;&lt; endl; exit(0); &#125; &#125; &#125;;class UI_Display //进去ATM后的UI界面类&#123;public: UI_Display() &#123; cout &lt;&lt; "--------------------------------" &lt;&lt; endl; cout &lt;&lt; "请按下列数字执行您所需服务！" &lt;&lt; endl; cout &lt;&lt; "1.查询余额 2.ATM取款" &lt;&lt; endl; cout &lt;&lt; "3.ATM存款 4.修改密码" &lt;&lt; endl; cout &lt;&lt; " 5.退出银行ATM机 " &lt;&lt; endl; cout &lt;&lt; "--------------------------------" &lt;&lt; endl; &#125; &#125;;class FileWriteNReading //读取文件并且对ATM的各项操作类&#123;private: int TotalMoney; int num,WithdrawingMoney,Saving; string os, pas1, pas2; string pas; string line1, line2,line3; char l,j,k;public: FileWriteNReading() &#123; TotalMoney=10000; l=0;j=0;k=0; ifstream fopen("D:\\inf.txt"); //读取D盘写入的inf.txt文件的信息 if (!fopen) &#123; cout &lt;&lt; "fail to read the file.\n"; &#125; while (!fopen.eof()) &#123; getline(fopen, line1); //读取第一行信息，下面以此类推。此处的目的是获取密码pas getline(fopen, line2); getline(fopen, line3); getline(fopen, pas); &#125; fopen.close(); while (1) //设置死循环 &#123; UI_Display(); cin &gt;&gt; num; switch (num) //利用switch语句，对要进行的操作进行选择 &#123; case 1://显示余额 show(); break; case 2://取款操作 cout &lt;&lt; "请输入您所需取款的金额且每次取款的金额为100的倍数，总额不超过5000元，不能透支取款:"; cin &gt;&gt; WithdrawingMoney; if (WithdrawingMoney % 100 == 0 &amp;&amp; WithdrawingMoney &lt;= 5000 &amp;&amp; WithdrawingMoney &lt;= TotalMoney) &#123; cout &lt;&lt; "您已取钱成功，取款金额为：" &lt;&lt; WithdrawingMoney &lt;&lt; endl; WithdrawingMoney1(WithdrawingMoney); &#125; else &#123; cout &lt;&lt; "您取钱失败，请检查输入金额是否为100的倍数或总额是否超过5000元或余额是否充足。" &lt;&lt; endl; &#125; break; case 3://存款操作 cout &lt;&lt; "请输入您所需存款的金额:"; cin &gt;&gt; Saving; if (Saving &gt;= 0) &#123; cout &lt;&lt; "您已存钱成功，存钱金额为：" &lt;&lt; Saving &lt;&lt; endl; Saving1(Saving); &#125; else &#123; cout &lt;&lt; "您存钱失败，请检查存入金额"&lt;&lt;endl; &#125; break; case 4://修改密码操作 cout &lt;&lt; "注意新密码不小于6位且不能出现6位数字相同\n"; cout &lt;&lt; "请输入原密码:"; char p[20]; while(p[l]=_getch()) //对输入的原密码进行不回显输入 &#123; if (p[l]!='\r') &#123; cout &lt;&lt; "*"; l++; &#125; else &#123;break;&#125; &#125; p[l]='\0'; os=p; if (os == pas) //如果密码与原来的密码相同，便修改密码成功 &#123; cout&lt;&lt;endl; cout &lt;&lt; "请输入修改后的密码:"; char q[20]; while(q[j]=_getch()) //第一次输入修改后的密码不回显输入 &#123; if (q[j]!='\r') &#123; cout &lt;&lt; "*"; j++; &#125; else &#123;break;&#125; &#125; q[j]='\0'; pas1=q; cout&lt;&lt;endl; cout &lt;&lt; "请再输入修改后的密码:";//第二次输入修改后的密码不回显输入 char r[20]; while(r[k]=_getch()) &#123; if (r[k]!='\r') &#123; cout &lt;&lt; "*"; k++; &#125; else &#123;break;&#125; &#125; r[k]='\0'; pas2=r; cout&lt;&lt;endl; if (pas1 == pas2) //对密码进行限制 &#123; int n;//将string的密码转换成int类型 n = atoi(pas1.c_str()); if (n &gt; 999999 || n &lt; 99999) //保证密码是6位 &#123; cout &lt;&lt; "请确认密码为6位！！\n"; break; &#125; //保证6位密码不相同 else if (n == 000000 || n == 111111 || n == 222222 || n == 333333 || n == 444444 || n == 555555 || n == 666666 || n == 777777 || n == 888888) &#123; cout &lt;&lt; "请确认密码不允许6位相同！！\n"; break; &#125; //保证原密码与新修改后的密码不相同 else if (n == 123456) &#123; cout &lt;&lt; "修改密码失败，你的密码与原密码相同！"&lt;&lt;endl; break; &#125; else &#123; cout &lt;&lt; "密码修改成功,请重新登陆账号！" &lt;&lt; endl; ofstream fout("D:\\inf.txt"); //密码修改成功后，重新对用户信息写入inf.txt if (!fout) &#123; cout &lt;&lt; "Fail to write to file.\n"; &#125; fout &lt;&lt; "该用户的账户为:" &lt;&lt; endl &lt;&lt; line2 &lt;&lt; endl &lt;&lt; "该用户的密码为:" &lt;&lt; endl &lt;&lt; pas1; fout.close(); BankAccount();//再次调用输入账户类 &#125; &#125; else &#123; cout &lt;&lt; "密码修改失败，请检查两次输入的密码是否一致。"&lt;&lt;endl; break; &#125; break; &#125; else &#123; cout &lt;&lt; "\n原密码输入错误，请检查！" &lt;&lt; endl &lt;&lt; endl; break; &#125; case 5://额外增加的选项，以便跳出死循环 cout&lt;&lt;"你已退出系统账户！"&lt;&lt;endl; exit(0); default: break; &#125; &#125; &#125; void WithdrawingMoney1(int WithdrawingMoney)&#123;TotalMoney -= WithdrawingMoney;&#125;//取款数额 void Saving1(int Saving)&#123;TotalMoney += Saving;&#125;//存款数额 void show()&#123;cout&lt;&lt;"你的账户余额为"&lt;&lt;TotalMoney&lt;&lt;"元"&lt;&lt;endl;&#125;//显示账户余额&#125;;int main()&#123; ofstream fout("D:\\inf.txt");//第一次写入D盘文件inf.txt if (!fout) &#123; cout &lt;&lt; "Fail to write to file.\n"; &#125; fout &lt;&lt; "该用户的账号为:\n" &lt;&lt; "123456" &lt;&lt; endl &lt;&lt; "该用户的密码为:\n" &lt;&lt; "123456" &lt;&lt; endl;//对用户的初始账户密码进行设置 fout.close(); BankAccount();//调用用户账户类 FileWriteNReading();//调用文件读写类&#125; 此代码在VS2015上正常运行~运行效果图: netbeans写可视化界面模拟银行ATM1.使用泛型，获取任何类型的账户密码余额12345678910111213141516171819202122232425262728293031public class ATM&lt;A,P,B&gt; &#123; private A account; private P password; private B balance; public ATM(A account,P password,B balance)&#123; this.setElem1(account); this.setElem2(password); this.setElem3(balance); &#125; public A getElem1()&#123; return account; &#125; public void setElem1(A account)&#123; this.account=account; &#125; public P getElem2()&#123; return password; &#125; public void setElem2(P password)&#123; this.password=password; &#125; public B getElem3()&#123; return balance; &#125; public void setElem3(B balance)&#123; this.balance=balance; &#125; public static void main(String[] args) &#123; ATMDBCon.JDBCon(); &#125; &#125; 2.JDBC连接数据库sql server1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.sql.*;import java.util.*;public class ATMDBCon &#123; //创建数据库连接的方法(JDBC) public static Connection JDBCon()&#123; try&#123; //--2 加载驱动程序 Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver"); // --3 创建连接 String url="jdbc:sqlserver://localhost:1433; databaseName=ATMDB"; Connection conn=DriverManager.getConnection(url,"sa",""); System.out.println("数据库连接成功"); return conn; &#125;catch(ClassNotFoundException ex)&#123; System.out.println("数据库驱动程序找不到"); return null; &#125;catch(SQLException ex)&#123; System.out.println("数据库连接失败"); ex.printStackTrace(); return null; &#125; &#125; //--查询数据的方法 public static Vector queryData(String sql)&#123; Connection conn=JDBCon(); try&#123; //创建会话对象 Statement stmt=conn.createStatement(); ResultSet rs=stmt.executeQuery(sql); Vector data=new Vector(); while(rs.next())&#123; String account=rs.getObject(1).toString(); String password=rs.getObject(2).toString(); String balance=rs.getObject(3).toString(); ATM&lt;String,String,String&gt; stu=new ATM&lt;String,String,String&gt;(account,password,balance); data.add(stu); &#125; //关闭 rs.close(); stmt.close(); conn.close(); return data; &#125;catch(SQLException ex)&#123; System.out.println("数据访问失败"); ex.printStackTrace(); return null; &#125; &#125; //--更新数据的方法(insert,update,delete) public static boolean updateData(String sql)&#123; Connection conn=JDBCon(); try&#123; //创建会话对象 Statement stmt=conn.createStatement(); //执行SQL语句，返回受影响的行数 int r=stmt.executeUpdate(sql); stmt.close(); conn.close(); if(r&gt;0)&#123; return true; &#125;else&#123; return false; &#125; &#125;catch(SQLException ex)&#123; System.out.println("数据更新失败"); ex.printStackTrace(); return false; &#125; &#125;&#125; 3.获取数据库登陆信息~如果账号密码都为123456则登陆成功12345678910111213141516// TODO add your handling code here:account=txtAccount.getText();password=txtPassword.getText();data=ATMDBCon.queryData("select * from userinfo");//ATM atm=(ATM)data.get(0); ATM&lt;String,String,String&gt; atm=(ATM&lt;String,String,String&gt;)data.get(0);if(account.equals(atm.getElem1())&amp;&amp;password.equals(atm.getElem2()))&#123; ATMDemo frame=new ATMDemo(); frame.setVisible(true); this.dispose();&#125;else&#123; JOptionPane.showMessageDialog(null,"账号或密码错误！","系统提示",JOptionPane.INFORMATION_MESSAGE); txtAccount.setText(""); txtPassword.setText(""); txtAccount.requestFocus();//选中密码框&#125; 4.获取数据库余额1234 data=ATMDBCon.queryData("select * from userinfo"); ATM&lt;String,String,String&gt; atm=(ATM&lt;String,String,String&gt;)data.get(0);// ATM atm=(ATM)data.get(0); JOptionPane.showMessageDialog(null,"Your current account balance is "+atm.getElem3()+" yuan","information",JOptionPane.INFORMATION_MESSAGE); 5.按照存款的要求进行存款1234567891011121314151617181920212223242526String str=txtgetdeposit.getText(); data=ATMDBCon.queryData("select * from userinfo"); //ATM atm=(ATM)data.get(0); ATM&lt;String,String,String&gt; atm=(ATM&lt;String,String,String&gt;)data.get(0); int j=Integer.parseInt(atm.getElem3()); int i; String sql=""; if(str!=null)&#123; try&#123; i=Integer.parseInt(str); if(i%100==0 &amp;&amp; i&gt;0)&#123; int k=i+j; sql="update userinfo SET balance="+k+""; ATMDBCon.updateData(sql); JOptionPane.showMessageDialog(null,"Deposit success","information",JOptionPane.INFORMATION_MESSAGE); dispose(); ATMDemo frame=new ATMDemo(); frame.setVisible(true); &#125;else&#123; JOptionPane.showMessageDialog(null,"Please enter an integer of 100!","information",JOptionPane.INFORMATION_MESSAGE); txtgetdeposit.setText(""); &#125; &#125;catch(NumberFormatException e)&#123; JOptionPane.showMessageDialog(null,"Please enter the correct deposit amount!","information",JOptionPane.INFORMATION_MESSAGE); &#125; &#125; 6.按照取款的要求进行取款123456789101112131415161718192021String str=txtwithdraw.getText();data=ATMDBCon.queryData("select * from userinfo");//ATM atm=(ATM)data.get(0); ATM&lt;String,String,String&gt; atm=(ATM&lt;String,String,String&gt;)data.get(0);int j=Integer.parseInt(atm.getElem3());int i;String sql="";if(str!=null)&#123; try&#123; i=Integer.parseInt(str); if(i&lt;=5000 &amp;&amp; i&lt;=j &amp;&amp; i%100==0 &amp;&amp; i&gt;0)&#123; int k=j-i; sql="update userinfo SET balance="+k+""; ATMDBCon.updateData(sql); JOptionPane.showMessageDialog(null,"Withdraw success","information",JOptionPane.INFORMATION_MESSAGE); ATMDemo frame=new ATMDemo(); frame.setVisible(true); dispose(); &#125;else&#123; JOptionPane.showMessageDialog(null,"Please enter an integer of 100 or below 5000 or less than total amount!","information",JOptionPane.INFORMATION_MESSAGE); txtwithdraw.setText(""); 7.修改密码操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889String oldpas=txtoldpas.getText();String newpas=txtnewpas.getText();String newpas1=txtnewpas1.getText();String k;data=ATMDBCon.queryData("select * from userinfo");//ATM atm=(ATM)data.get(0); ATM&lt;String,String,String&gt; atm=(ATM&lt;String,String,String&gt;)data.get(0); String m=atm.getElem1(); String n=atm.getElem2(); String sql="";if(oldpas!=null &amp;&amp; newpas!=null &amp;&amp; newpas1 !=null)&#123; if(oldpas.equals(atm.getElem2()))&#123; try&#123; int i=Integer.parseInt(newpas); int j=Integer.parseInt(newpas1); if(i==j)&#123; if(i!=Integer.parseInt(oldpas) &amp;&amp; i&lt;999999 &amp;&amp;i&gt;99999 &amp;&amp; i!=111111 &amp;&amp; i!=22222 &amp;&amp; i!=333333 &amp;&amp; i!=444444 &amp;&amp; i!=555555 &amp;&amp; i!= 666666 &amp;&amp; i!= 777777 &amp;&amp; i!= 888888)&#123; k=String.valueOf(j); sql="update userinfo SET password='"+k+"'"; ATMDBCon.updateData(sql); JOptionPane.showMessageDialog(null,"Modify password success!","information",JOptionPane.INFORMATION_MESSAGE); try&#123; FileOutputStream f=new FileOutputStream("D:\\info.txt");//构造FileInputStream对象 ObjectOutputStream out=new ObjectOutputStream(f);//构造ObjectInputStream对象 modifypas stu=new modifypas(atm.getElem1(),n,k);//使用ObjectInputStream对象的readObect（）方法进行序列化 out.writeObject(stu);//使用ObjectOutStream对象的writeObject（）方法进行序列化 out.close();//关闭ObjectOutSteram对象 f.close();//关闭FileOutputStream对象 &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; System.out.println("序列化完毕"); try&#123; FileInputStream f=new FileInputStream("D:\\info.txt");//构造FileInputStream对象 ObjectInputStream in = new ObjectInputStream(f);//构造ObjectInputStream对象 modifypas stu1=(modifypas)in.readObject();//使用ObjectInputStream对象的readObect（）方法进行反序列化 System.out.println(stu1.toString()); //System.out.println("----------------------------"); //System.out.println("卡号："+stu1.account1+";密码："+stu1.password1+";修改后的密码："+stu1.password2); in.close();//关闭ObjectOutSteram对象 f.close();//关闭FileOutputStream对象 &#125;catch(ClassNotFoundException e)&#123; e.printStackTrace(); &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; System.out.println("反序列化完毕"); dispose(); Login frame=new Login(); frame.setVisible(true); //setDefaultCloseOperation(ATMDemo.DISPOSE_ON_CLOSE) &#125;else if(i==Integer.parseInt(oldpas))&#123; JOptionPane.showMessageDialog(null,"Old and New passwords are same!!","information",JOptionPane.INFORMATION_MESSAGE); txtoldpas.setText(""); txtnewpas.setText(""); txtnewpas1.setText(""); txtoldpas.requestFocus(); &#125;else&#123; JOptionPane.showMessageDialog(null,"Password is not six or password identical!!","information",JOptionPane.INFORMATION_MESSAGE); txtoldpas.setText(""); txtnewpas.setText(""); txtnewpas1.setText(""); txtoldpas.requestFocus(); &#125; &#125;else&#123; JOptionPane.showMessageDialog(null,"Two input passwords are not the same!!","information",JOptionPane.INFORMATION_MESSAGE); txtoldpas.setText(""); txtnewpas.setText(""); txtnewpas1.setText(""); txtoldpas.requestFocus(); &#125; &#125;catch(NumberFormatException e)&#123; JOptionPane.showMessageDialog(null,"Please enter a digital password!","information",JOptionPane.INFORMATION_MESSAGE); txtoldpas.setText(""); txtnewpas.setText(""); txtnewpas1.setText(""); txtoldpas.requestFocus(); &#125; &#125;else&#123; JOptionPane.showMessageDialog(null,"Old Password error!","information",JOptionPane.INFORMATION_MESSAGE); txtoldpas.setText(""); txtnewpas.setText(""); txtnewpas1.setText(""); txtoldpas.requestFocus(); &#125;&#125;else&#123; JOptionPane.showMessageDialog(null,"Please input a password!","information",JOptionPane.INFORMATION_MESSAGE);&#125; 8.按回车登录事件在构造函数处添加以下代码即可12 getRootPane().setDefaultButton(btnLogin);&lt;!-- btnLogin表示登陆按钮的名称，存取款修改密码类似 --&gt; 附上界面图：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二分搜索技术]]></title>
      <url>%2F2017%2F01%2F16%2Fbinarysearch%2F</url>
      <content type="text"><![CDATA[去不了的地方叫远方，回不去的是故乡~ 前言二分搜索技术是算法里面最简单的查找一个数所在位置的算法。 二分搜索技术复杂度每执行一次算法的while循环，待搜索数组的大小减少一半，因此在最坏情况下，while循环被执行了O（logn）次。在循环体内运算需要O（1）时间，因此整个算法在最坏的情况下的计算时间复杂性为O（logn). 代码 此代码在VS2015上正常运行~12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt; using namespace std;template&lt;class Type&gt; //在已经排好序的a[0]~a[n-1]当中搜索xint BinarySearch(Type a[], const Type&amp;x, int n)&#123; int left = 0; int right = n - 1; while (left&lt;=right) &#123; int middle = (left + right) / 2; if (x==a[middle]) &#123; return middle;//返回x所在数组a的位置 &#125; if (x&gt;a[middle]) &#123; left = middle + 1; &#125; else &#123; right = middle - 1; &#125; &#125; return -1;//如果不存在，返回-1&#125;int main() &#123; char m = 4; //cout &lt;&lt; m&lt;&lt;endl; char y[5] = &#123; 1,2,3,4&#125;; int w=4; w = BinarySearch(y, m, w); cout &lt;&lt; w&lt;&lt;endl; system("pause"); return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java仿QQ聊天实现]]></title>
      <url>%2F2017%2F01%2F16%2Fqq%2F</url>
      <content type="text"><![CDATA[你交回录取通知书，忘了十年寒窗~ 前言利用网络编程仿照QQ聊天实现的代码。 客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.io.*;import java.net.*;import java.util.Date;public class ClientDemo &#123; public static void main(String[] args)throws IOException &#123; Socket serverSocket=null; PrintWriter printWriter=null; BufferedReader serverBufferedReader=null; boolean runable=true; String toServer; try&#123; serverSocket=new Socket("127.0.0.1",1234); printWriter=new PrintWriter(serverSocket.getOutputStream(),true); serverBufferedReader=new BufferedReader(new InputStreamReader(serverSocket.getInputStream())); &#125;catch(UnknownHostException e)&#123; System.err.println("找不到服务器"); e.printStackTrace(); System.exit(0); &#125;catch(IOException e)&#123; System.err.println("不能获得Socket的读入与写出器"); e.printStackTrace(); System.exit(0); &#125; BufferedReader keyBufferedReader=new BufferedReader(new InputStreamReader(System.in)); printWriter.println("新的用户登录"); ReadServerThread readServerThread=new ReadServerThread(serverBufferedReader); readServerThread.start(); while(runable)&#123; Date d=new Date(); toServer=keyBufferedReader.readLine(); printWriter.println(toServer+"\t"+d.getHours()+":"+d.getMinutes()+":"+d.getSeconds()); if(toServer.equals("bye."))break; runable=readServerThread.runable; &#125; readServerThread.fromServer="欢迎下次再来"; readServerThread.runable=false; printWriter.close(); serverBufferedReader.close(); keyBufferedReader.close(); serverSocket.close(); &#125;&#125;class ReadServerThread extends Thread&#123; BufferedReader in=null; String fromServer=""; boolean runable=true; public ReadServerThread(BufferedReader in)&#123; this.in=in; &#125;public void run()&#123; while(runable)&#123; try&#123; fromServer=in.readLine(); &#125;catch(Exception e)&#123; runable=false; &#125; if(fromServer.equals("bye."))&#123; System.out.println("客户端退出"); runable=false; break; &#125; System.out.println("客户端："+fromServer); &#125; &#125;&#125; 服务端代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.net.*;import java.util.Date;import java.io.*;public class ServerDemo &#123; public static void main(String[] args)throws IOException&#123; String toClient; PrintWriter clientPrintWriter=null; BufferedReader clientBufferedReader=null; boolean runable=true; ServerSocket serverSocket=null; try&#123; serverSocket=new ServerSocket(1234); &#125;catch(IOException e)&#123; System.err.println("不能创建1234端口"); e.printStackTrace(); System.exit(0); &#125; Socket clientSocket=null; try&#123; clientSocket=serverSocket.accept(); &#125;catch(IOException e)&#123; System.err.println("访问端口失败"); e.printStackTrace(); System.exit(1); &#125; clientPrintWriter=new PrintWriter(clientSocket.getOutputStream(),true); clientBufferedReader=new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); BufferedReader keyBufferedReader=new BufferedReader(new InputStreamReader(System.in)); toClient="你好，欢迎你！"; clientPrintWriter.println(toClient); ReadClientThread readClientThread=new ReadClientThread(clientBufferedReader); readClientThread.start(); while(runable)&#123; Date d=new Date(); toClient=keyBufferedReader.readLine(); clientPrintWriter.println(toClient+"\t"+d.getHours()+":"+d.getMinutes()+":"+d.getSeconds()); if(toClient.equals("bye."))break; runable=readClientThread.runable; &#125; readClientThread.fromClient="欢迎下次再来。"; readClientThread.runable=false; clientPrintWriter.close(); keyBufferedReader.close(); serverSocket.close(); &#125;&#125;class ReadClientThread extends Thread&#123; BufferedReader bufferedReader=null; String fromClient=""; boolean runable=true; public ReadClientThread(BufferedReader in)&#123; this.bufferedReader=in; &#125; public void run()&#123; while(runable)&#123; try&#123; fromClient=bufferedReader.readLine(); &#125;catch(Exception e)&#123; runable=false; &#125; if(fromClient.equals("bye."))&#123; System.out.println("客户端退出"); runable=false; break; &#125; System.out.println("客户端："+fromClient); &#125; &#125;&#125; 运行工具为eclipse 2014，结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PS,AI设计]]></title>
      <url>%2F2017%2F01%2F14%2Fphoto%2F</url>
      <content type="text"><![CDATA[我希望有一个如你一般的，如山间清爽的风，如古城温暖的光，从清晨到夜晚，由山野到书屋，只要最后是你就好。 设计之前用PS和AI等工具设计了很多海报和图片，暂时找到这么多，存着。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文件管理之文件系统设计]]></title>
      <url>%2F2017%2F01%2F14%2Fospassage%2F</url>
      <content type="text"><![CDATA[当夜幕降临时，在太阳以西，国境以南处，等候你的归来~ 前言这是操作系统课上的一个课后作业，操作系统考完后基本就忘记的差不多了，把这个实践代码在这里重新过一遍~ 文件管理之文件系统设计实验目的本实验的目的是使学生在学习文件系统原理的基础上，通过参考成熟的操作系统中文件系统的设计，实现一个简单的多用户文件系统，加深对文件系统的功能、内部结构包括逻辑结构以及物理结构的理解。 实验内容设计一个简单的二级文件系统。要求实现下列命令：12345login 用户登录dir 列文件目录create 创建文件delete 删除文件 &lt;!-- 列目录时要列出文件名、物理地址、文件长度。--&gt; 实验提示 1.首先设计文件系统的物理结构、模拟磁盘存储结构（目录与文件的组织方式）。 2.确定文件系统的数据结构：主目录、子目录及活动文件等。主目录和子目录都可以文件的形式存放于磁盘，这样便于查找和修改。 3.用户创建的文件，可以编号存储于模拟磁盘上。如file0，file1，file2，.…..并以编号作为物理地址，在目录中进行登记。 实验说明 可以参考现有的系统如FAT、NTFS或ext3等系统的结构。 同学在完成基本功能的基础上可以考虑对系统的扩展，如多级目录、文件的共享以及系统的优化，如目录查找算法的改进等。 实现代码 此代码在VS2015上正常运行~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#define MaxUser 100//定义最大MDF主目录文件#define MaxDisk 512*1024//模拟最大磁盘空间#define commandAmount 12//对文件操作的指令数//存储空间管理有关结构体和变量char disk[MaxDisk];//模拟512K的磁盘存储空间typedef struct distTable//磁盘块结构体&#123; int maxlength; int start; int useFlag; distTable *next;&#125;diskNode;diskNode *diskHead;struct fileTable//文件块结构体&#123; char fileName[10]; int strat;//文件在磁盘存储空间的起始地址 int length;//文件内容长度 int maxlength;//文件的最大长度 char fileKind[3];//文件的属性——读写方式 struct tm *timeinfo; bool openFlag;//判断是否有进程打开了该文件//fileTable *next;&#125;;//两级目录结构体typedef struct user_file_directory//用户文件目录文件UFD&#123; //char fileName[10]; fileTable *file; user_file_directory *next;&#125;UFD;//UFD *headFile;typedef struct master_file_directory//主文件目录MFD&#123; char userName[10]; char password[10]; UFD *user;&#125;MFD;MFD userTable[MaxUser];int used = 0; //定义MFD目录中用已有的用户数//文件管理void fileCreate(char fileName[], int length, char fileKind[]);//创建文件void fileDir(char UserName[]); //显示某一用户的所有文件void fileDel(char fileName[]); //删除文件int requestDist(int &amp;startPostion, int maxLength); //磁盘分配查询void initDisk(); //初始化磁盘void userCreate();//用户管理int login();int userID = -1;//用户登录的ID号，值为-1时表示没有用户登录int main()&#123; char order[commandAmount][10]; strcpy(order[1], "create"); strcpy(order[2], "del"); strcpy(order[3], "dir"); strcpy(order[0], "0"); char command[50], command_str1[15], command_str2[15], command_str3[15], command_str4[13]; int i, k, j; int length; initDisk(); //初始化磁盘 for (i = 0; i&lt;MaxUser; i++)//初始化用户UFD目录文件的头指针 &#123; userTable[i].user = (UFD *)malloc(sizeof(UFD)); userTable[i].user-&gt;next = NULL; &#125; while (1) &#123; printf("\n"); printf(" 1、Creat user\n"); printf(" 2、login\n"); printf("\n"); printf("Please chooce the function key:&gt;"); int choice; scanf("%d", &amp;choice); if (choice == 1) userCreate(); else if (choice == 2) userID = login(); else printf("您的输入有误，请重新选择\n"); while (userID != -1) &#123; fflush(stdin); gets_s(command); printf("———————————————————————————————————————\n"); printf(" create-创建 格式：create a1 1000 rw,将创建名为a1,长度为1000字节可读可写的文件\n"); printf(" del-删除 格式：del a1,将删除名为a1的文件\n"); printf(" dir-显示文件 格式：dir aaa,将显示aaa用户的所有文件\n"); printf(" exit-退出程序(输入exit时在后面加一个空格，否则退出异常)\n"); printf("————————————————————————————————————————\n"); printf("please imput your command:&gt;"); gets_s(command); int select; //command_str1字符串存储命令的操作类型 for (i = 0; command[i] != ' '&amp;&amp;command[i] != '\0'; i++) command_str1[i] = command[i]; k = i; command_str1[k] = '\0'; for (i = 0; i&lt;commandAmount; i++) &#123; if (!strcmp(command_str1, order[i])) &#123; select = i; break; &#125; &#125; if (i == commandAmount) &#123; printf("您输入的命令有误，请重新输入\n"); continue; &#125; //commmand_str2字符串存储文件名或用户名 for (i = k + 1, k = 0; command[i] != ' '&amp;&amp;command[i] != '\0'; i++, k++) command_str2[k] = command[i]; command_str2[k] = '\0'; k = i; switch (select) &#123; case 1:for (i = k + 1, k = 0; command[i] != ' '; i++, k++) command_str3[k] = command[i]; command_str3[k] = '\0'; k = i; j = 1; length = 0;//初始化文件长度 for (i = strlen(command_str3) - 1; i &gt;= 0; i--) //把字符串转换为十进制 &#123; length += (command_str3[i] - 48)*j; j *= 10; &#125; for (i = k + 1, k = 0; command[i] != ' '&amp;&amp;command[i] != '\0'; i++, k++) command_str4[k] = command[i]; command_str4[k] = '\0'; fileCreate(command_str2, length, command_str4); break; case 2:fileDel(command_str2); break; case 3:fileDir(command_str2); break; case 0:exit(1); default: break; &#125; &#125; &#125; return 0;&#125;void userCreate()&#123; char c; char userName[10]; int i; if (used&lt;MaxUser) &#123; printf("请输入用户名："); for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else userName[i] = c; printf("%c", c); &#125; userName[i] = '\0'; for (i = 0; i&lt;used; i++) &#123; if (!strcmp(userTable[i].userName, userName)) &#123; printf("\n"); printf("该用户名已存在,创建用户失败\n"); system("pause"); return; &#125; &#125; strcpy(userTable[used].userName, userName); printf("\n"); printf("请输入密码："); for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else userTable[used].password[i] = c; printf("*"); &#125; userTable[userID].password[i] = '\0'; printf("\n"); printf("创建用户成功\n"); used++; system("pause"); &#125; else &#123; printf("创建用户失败，用户已达到上限\n"); system("pause"); &#125; fflush(stdin);&#125;int login()&#123; char name[10], psw[10]; char c; int i, times; printf("请输入用户名:"); for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else name[i] = c; printf("%c", c); &#125; name[i] = '\0'; for (i = 0; i&lt;used; i++) &#123; if (!strcmp(userTable[i].userName, name)) break; &#125; if (i == used) &#123; printf("\n您输入的用户名不存在\n"); system("pause"); return -1; &#125; for (times = 0; times&lt;3; times++) &#123; memset(psw, '\0', sizeof(psw)); printf("\n请输入密码:"); /*for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else psw[i] = c; printf("*"); &#125; printf("\n");*/ int i = 0; while (psw[i]=_getch()) &#123; if (psw[i]!='\r') &#123; printf("*"); i++; &#125; else &#123; break; &#125; &#125; psw[i] = '\0'; printf("\n"); for (i = 0; i&lt;used; i++) &#123; if (!strcmp(psw, userTable[i].password)) &#123; printf("用户登录成功\n"); system("pause"); break; &#125; &#125; if (i == used) &#123; printf("\n您输入的密码错误，您还有%d次输入机会\n", 2 - times); if (times == 2) exit(0); &#125; else break; &#125; fflush(stdin); return i;&#125;void initDisk()&#123; diskHead = (diskNode *)malloc(sizeof(diskNode)); diskHead-&gt;maxlength = MaxDisk; diskHead-&gt;useFlag = 0; diskHead-&gt;start = 0; diskHead-&gt;next = NULL;&#125;int requestDist(int &amp;startPostion, int maxLength)&#123; int flag = 0; //标记是否分配成功 diskNode *p, *q, *temp; p = diskHead; while (p) &#123; if (p-&gt;useFlag == 0 &amp;&amp; p-&gt;maxlength&gt;maxLength) &#123; startPostion = p-&gt;start; q = (diskNode *)malloc(sizeof(diskNode)); q-&gt;start = p-&gt;start; q-&gt;maxlength = maxLength; q-&gt;useFlag = 1; q-&gt;next = NULL; diskHead-&gt;start = p-&gt;start + maxLength; diskHead-&gt;maxlength = p-&gt;maxlength - maxLength; flag = 1; temp = p; if (diskHead-&gt;next == NULL) diskHead-&gt;next = q; else &#123; while (temp-&gt;next) temp = temp-&gt;next; temp-&gt;next = q; &#125; break; &#125; p = p-&gt;next; &#125; return flag;&#125;void fileCreate(char fileName[], int length, char fileKind[])&#123; //int i,j; time_t rawtime; int startPos; UFD *fileNode, *p; for (p = userTable[userID].user-&gt;next; p != NULL; p = p-&gt;next) &#123; if (!strcmp(p-&gt;file-&gt;fileName, fileName)) &#123; printf("文件重名，创建文件失败\n"); system("pause"); return; &#125; &#125; if (requestDist(startPos, length)) &#123; fileNode = (UFD *)malloc(sizeof(UFD)); //这一步必不可少，因为fileNode里面的指针也需要申请地址，否则fileNode-&gt;file指向会出错 fileNode-&gt;file = (fileTable *)malloc(sizeof(fileTable)); strcpy(fileNode-&gt;file-&gt;fileName, fileName); strcpy(fileNode-&gt;file-&gt;fileKind, fileKind); fileNode-&gt;file-&gt;maxlength = length; fileNode-&gt;file-&gt;strat = startPos; fileNode-&gt;file-&gt;openFlag = false; time(&amp;rawtime); fileNode-&gt;file-&gt;timeinfo = localtime(&amp;rawtime); fileNode-&gt;next = NULL; if (userTable[userID].user-&gt;next == NULL) userTable[userID].user-&gt;next = fileNode; else &#123; p = userTable[userID].user-&gt;next; while (p-&gt;next) p = p-&gt;next; p-&gt;next = fileNode; &#125; printf("创建文件成功\n"); printf("按任意键继续..."); //system("pause"); &#125; else &#123; printf("磁盘空间已满或所创建文件超出磁盘空闲容量，磁盘空间分配失败\n"); printf("按任意键继续..."); //system("pause"); &#125;&#125;void freeDisk(int startPostion)&#123; diskNode *p; for (p = diskHead; p != NULL; p = p-&gt;next) &#123; if (p-&gt;start == startPostion) break; &#125; p-&gt;useFlag = false;&#125;void fileDel(char fileName[])&#123; UFD *p, *q, *temp; q = userTable[userID].user; p = q-&gt;next; while (p) &#123; if (!strcmp(p-&gt;file-&gt;fileName, fileName)) break; else &#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; if (p) &#123; if (p-&gt;file-&gt;openFlag != true) //先判断是否有进程打开该文件 &#123; temp = p; q-&gt;next = p-&gt;next; freeDisk(temp-&gt;file-&gt;strat);//磁盘空间回收 free(temp); printf("文件删除成功\n"); printf("按任意键继续..."); //system("pause"); &#125; else &#123; printf("该文件已被进程打开,删除失败\n"); printf("按任意键继续..."); //system("pause"); &#125; &#125; else &#123; printf("没有找到该文件,请检查输入的文件名是否正确\n"); printf("按任意键继续..."); //system("pause"); &#125;&#125;void fileDir(char userName[])&#123; UFD *p; int i, k; for (i = 0; i&lt;MaxUser; i++) &#123; if (!strcmp(userTable[i].userName, userName)) &#123; k = i; break; &#125; &#125; if (i == MaxUser) &#123; printf("没有找到该用户，请检查输入用户名是否正确\n"); printf("按任意键继续..."); //system("pause"); return; &#125; else &#123; p = userTable[k].user-&gt;next; printf("\n"); printf("文件名 文件长度 文件在磁盘的起始地址 文件类型 创建时间\n"); for (; p != NULL; p = p-&gt;next) printf("%s %d %d %s %s", p-&gt;file-&gt;fileName, p-&gt;file-&gt;maxlength, p-&gt;file-&gt;strat, p-&gt;file-&gt;fileKind, asctime(p-&gt;file-&gt;timeinfo)); printf("\n"); printf("按任意键继续..."); //system("pause"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基数排序]]></title>
      <url>%2F2017%2F01%2F14%2Fshujujiegou%2F</url>
      <content type="text"><![CDATA[如果一片瓦尔登湖不能荡涤心灵，那就没办法了~ 前言数据结构实践任务，花了几个星期在网上找，都是不完全的版本，加入自己的理解写下能排数字和字母的基数排序~ 基数排序问题描述对输入的关键字序列进行链式基数排序，并分析算法复杂度。 任务要求1) 对输入的自然数关键字序列进行链式基数排序。2) 需排序的数据是英文单词，从文件中读取；按字典顺序排列，写文件保存。 测试数据输入自然数关键字序列：278，109，63，930，589，184，505，269，8，83。输入英文单词组成的文件，按字典排序并输出到文件中。 解释第一个自然数关键字排序直接在cmd窗口输入即可排序。第二个读取字母并排序之前需要在D盘中创建一个f1.txt文件，在里面输入10个长度小于等于9的单词，每输入一个单词换行。这里不管是自然数还是单词统一使用MSD优先排序（即从前往后对比）。具体排序思路参考严蔚敏的数据结构。 算法复杂度分析 代码 此代码在VS2015上正常运行~ #include &lt;iostream&gt; #include &lt;fstream&gt; //文件输入输出流 #include&lt;string&gt; using namespace std; //数字结构体 #define MAX_NUM_OF_KEY 8//关键字项数的最大值 #define RADIX 10//关键字基数，此时是十进制整数的基数 #define MAX_SPACE 10000 typedef int DataType; typedef struct { int data;//数据，如278 DataType keys[MAX_NUM_OF_KEY];//每个数据的所有关键字，278的2，7，8 int next; }SLCell; //静态链表的节点类型 typedef struct Sllist { SLCell *R; //静态链表的可利用空间，r[0]为头结点 int recnum; //静态链表的当前长度 int keynum; //当前数据的关键字个数 }Sllist, *SLList; //静态链表类型 typedef int ArrType[RADIX];//指针数组类型，声明两个指针数组，一个头指针，一个尾指针 //字母结构体 #define MaxLen 9 //单词的最大长度 #define Radix 27 //基数rd为27,分别对应' ','a',…'z' typedef char String[MaxLen + 1];//定义String为字符数组类型 typedef struct node { String word; //单词 struct node *next; //next指针 } LinkNode; //数字基数排序 void creatList(SLList &amp;SLL) //创建链表 { int key; int i = 1, j; cout &lt;&lt; "输入要进行排序的数字(输入0结束):" &lt;&lt; endl; cin &gt;&gt; key; while (key != 0) { SLL-&gt;R[i].data = key; for (j = 1; j &lt;= SLL-&gt;keynum; j++) { SLL-&gt;R[i].keys[j] = key % 10; key /= 10; } SLL-&gt;R[i - 1].next = i++; cin &gt;&gt; key; } SLL-&gt;recnum = i - 1; SLL-&gt;R[SLL-&gt;recnum].next = 0; } //打印输出 void print(SLList &amp;SLL) { for (int p = SLL-&gt;R[0].next; p; p = SLL-&gt;R[p].next) { cout &lt;&lt;"["&lt;&lt; SLL-&gt;R[p].data &lt;&lt;"]"&lt;&lt; " "; } cout &lt;&lt; endl; } //分配算法 void distribute(SLCell *R, int i, ArrType front, ArrType end) { //静态链表L的R域中记录已按(keys[0]...keys[i-1]有序)。 //本算法按第i个关键字keys[i]建立RADIX个子表，使同一子表中记录的keys[i]相同。 //front[0...RADIX-1]和end[0...RADIX-1]分别指向各子表中第一个和最后一个记录。 int j; for (int j = 0; j&lt;RADIX; ++j) front[j] = 0; //各子表初始化为空表 for (int p = R[0].next; p; p = R[p].next) { j = R[p].keys[i]; //映射第i个关键字 if (!front[j]) front[j] = p; //若front[j]为空，则把记录连接到front[j]的头指针上 else R[end[j]].next = p; //若front[j]的头指针已经连接过了，说明已j为关键字的数据已经有了， //这时把上一个以j为关键字的数据指向当前的这个数，即下标为p的数据 end[j] = p; //尾指针重新指到每次更新的数据上 } } //收集算法 void collect(SLCell *R, int i, ArrType front, ArrType end) { //本算法按keys[i]自小到大地将f[0...RADIX-1]所指各子表依次链接成为一个链表 int j; for (j = 0; !front[j]; j++); //找到第一个不为空的子表 R[0].next = front[j]; //重整静态链表 int k = end[j]; //k为当前子表的尾指针 while (j&lt;RADIX) { for (++j; j&lt;RADIX; j++) if (front[j]) //找下一个非空子表 { R[k].next = front[j]; //连接 k = end[j]; } } R[k].next = 0; //k指向最后一个非空子表的尾指针 } //字母基数排序 void DispWord(String R[], int n) //输出单词 { int i; string o[10]; ofstream fout("D:\\inf.txt"); //排序成功后，重新对排序写入inf.txt if (!fout) { cout &lt;&lt; "Fail to write to file.\n"; } for (i = 0; i &lt; n; i++) { cout &lt;&lt; "[" &lt;&lt; R[i] &lt;&lt; "]"; o[i] = R[i]; fout &lt;&lt; "["&lt;&lt;o[i]&lt;&lt;"]" &lt;&lt; endl; } cout &lt;&lt; endl; fout.close(); } void PreProcess(String R[], int n) //对单词进行预处理,用空格填充尾部至MaxLen长 { int i, j; for (i = 0; i&lt;n; i++) { if (strlen(R[i])&lt;MaxLen) { for (j = strlen(R[i]); j&lt;MaxLen; j++) R[i][j] = ' '; R[i][j] = '\0'; } } } void EndProcess(String R[], int n) //恢复处理,删除预处理时填充的尾部空格 { int i, j; for (i = 0; i&lt;n; i++) { for (j = MaxLen - 1; R[i][j] == ' '; j--); R[i][j + 1] = '\0'; } } void Distribute(String R[], LinkNode *head[], LinkNode *tail[], int j, int n) //按关键字的第j个分量进行分配,进入此过程时各队列一定为空 { int i, k; LinkNode *p; for (i = 0; i&lt;n; i++) //依次扫描R[i],将其入队 { if (R[i][j] == ' ') //空格时放入0号队列中,'a'时放入1号队列中,… k = 0; else k = R[i][j] - 'a' + 1; p = (LinkNode *)malloc(sizeof(LinkNode)); //创建新结点 strcpy_s(p-&gt;word, R[i]); p-&gt;next = NULL; if (head[k] == NULL) { head[k] = p; tail[k] = p; } else { tail[k]-&gt;next = p; tail[k] = p; } } } void Collect(String R[], LinkNode *head[]) //依次将各非空队列中的记录收集起来 { int k = 0, i; LinkNode *p; for (i = 0; i&lt;Radix; i++) for (p = head[i]; p != NULL; p = p-&gt;next) strcpy_s(R[k++], p-&gt;word); } void RadixSort(String R[], int n) //对R[0..n-1]进行基数排序 { LinkNode *head[Radix], *tail[Radix]; //定义Radix个队列 int i, j; int k = 1; for (i = MaxLen - 1; i &gt;= 0; i--) //从低位到高位做d趟箱排序 { for (j = 0; j&lt;Radix; j++) head[j] = tail[j] = NULL; //队列置空 Distribute(R, head, tail, i, n); //第i趟分配 Collect(R, head); //第i趟收集 cout &lt;&lt; "第" &lt;&lt; k &lt;&lt; "趟分配和收集:" &lt;&lt; endl; for (int m = 0; m &lt;10; m++) { cout&lt;&lt;"["&lt;&lt;R[m]&lt;&lt;"]"; } k++; cout &lt;&lt; endl; } } //主函数 int main() { SLList SLL; SLL = (SLList)malloc(MAX_SPACE * sizeof(Sllist)); SLL-&gt;R = (SLCell *)malloc(MAX_SPACE * sizeof(SLCell)); SLL-&gt;recnum = 0; SLL-&gt;keynum = 3; string R[10]; String c[10]; ifstream fopen("D:\\f1.txt");//读取D盘inf.txt文件 if (!fopen) { cout &lt;&lt; "fail to read the file.\n"; } while (!fopen.eof()) { //读取D盘写入的文件 for (int q = 0; q&lt;10; q++) { getline(fopen, R[q]); //读取第一行 strcpy_s(c[q],R[q].c_str()); } } fopen.close(); /*ofstream fout("D:\\inf.txt"); //排序成功后，重新对用户信息写入inf.txt if (!fout) { cout &lt;&lt; "Fail to write to file.\n"; } for (int o = 0; o &lt; 10; o++) { fout &lt;&lt; c[o] &lt;&lt; endl; } fout.close();*/ int k; while (1) { cout &lt;&lt; "*************基数排序程序***************" &lt;&lt; endl; cout &lt;&lt; "* 选择要执行的命令 *" &lt;&lt; endl; cout &lt;&lt; "* 1.输入自然数进行链式基数排序 *" &lt;&lt; endl; cout &lt;&lt; "* 2.从文件中读取字母,按字典顺序排列 *" &lt;&lt; endl; cout &lt;&lt; "* 3.退出程序 *" &lt;&lt; endl; cout &lt;&lt; "****************************************" &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; cin &gt;&gt; k; switch (k) { case 1: creatList(SLL); cout &lt;&lt; "排序前:" &lt;&lt; endl; print(SLL); ArrType front, end; for (int i = 1; i &lt;= SLL-&gt;keynum; i++) //按LSD法对各关键字进行分配和收集 { distribute(SLL-&gt;R, i, front, end); //第i趟分配 collect(SLL-&gt;R, i, front, end); //第i趟收集 cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "趟分配和收集:" &lt;&lt; endl; print(SLL); } cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; break; case 2: cout &lt;&lt; "从D:\\f1.txt中读取到的单词为：" &lt;&lt; endl; DispWord(c, 10); PreProcess(c, 10); cout &lt;&lt; "预处理后：" &lt;&lt; endl; DispWord(c, 10); RadixSort(c, 10); cout &lt;&lt; "排序结果：" &lt;&lt; endl; DispWord(c, 10); EndProcess(c, 10); cout &lt;&lt; "最终结果：" &lt;&lt; endl; DispWord(c, 10); cout &lt;&lt; "******排序后的结果已经成功写入D盘inf.txt!******"; cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; break; case 3: exit(0); default: cout &lt;&lt; "请输入正确的数字！" &lt;&lt; endl; break; } } return 0; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记录Hexo+Github免费搭建个人博客]]></title>
      <url>%2F2017%2F01%2F13%2Fnew-article%2F</url>
      <content type="text"><![CDATA[不急，先上一首歌曲，然后慢慢记录~ 动机这几天一直在利用Hexo搭建自己的博客，对于hexo的强大能力感到赞叹，中途谷歌百度了很多教程，一路经历各种坎坷艰辛，而且别人的教程版本都很旧，在自己摸索下终于完成了现在这个博客，博客刚建立，文章少的可怜，就用来暖暖场吧~，也为了不使自己忘记，也因为一直有记录的习惯，算是个人笔记写一下这个博客的搭建记录吧~ 这个记录流程只适用于windows 准备工具1.Node.js2.Git 安装Hexo上面两个文件安装好之后，在你觉得合适的位置，建立一个文件夹（命名不要写中文！下面以该文件夹命名为Hexo为例），进入该文件夹，右击鼠标选择Git Bash,然后输入下列文字（目的是安装Hexo,$已经帮你打好,为了形象在此加入$）:1$ npm install hexo-cli -g 在本地搭建Hexo安装Hexo后，继续在当前 Git Bash里面按顺序执行以下命令(中途也许会看到warn提醒，可以不管)：123456$ npm install hexo --save$ hexo -v$ hexo init$ npm install$ hexo g$ hexo s 当你执行完hexo s后，你会看到 “INFO Hexo is running at http : //0.0.0.0:4000/.Press Ctrl+C to stop.”这句话这时候，不要关闭git bash，在高级浏览器（chorm，火狐，等）输入http://localhost:4000 你就可以看到你的博客了。 为你的博客更换主题hexo为我们提供了很多主题,如果你觉得初始主题已经不错了，那就不用更换了，下面以主题Next为例，继续记录~~在../Hexo下打开Git Bash 输入：1$ git clone https://github.com/iissnan/hexo-theme-next 这表示下载Next主题，等待主题下载完毕~~然后在打开../Hexo/_config.yml，建议是使用Notepad++,用Notepad++打开后ctrl+F弹出搜索框，输入关键字theme:，然后找到theme: 后大概是这样的1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 这时候把landscape改为:（如果手打记得冒号后面必须加一个空格！）1theme: next 然后在Git hash先执行hexo clean，然后执行hexo g，再执行hexo s，很快就能看到新主题的效果了~&gt;Next有三套主题选择，打开../Hexo/themes/next/_config.yml 搜索关键字Schemes:1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces #代表注释，如果去掉#就说明使用当前主题。下面以使用Next.Mist主题为例.. 配置个人博客打开../Hexo/_config.yml1234567# Sitetitle: “你的博客名字”subtitle: “副标题”description: “描述”author: “作者”language: zh-Hans“这里的设置请参考下图”timezone: 打开../Hexo/themes/next/_config.yml 1234567891011121314151617181920menu: home: / archives: /archives categories: /categories tags: /tags about: /about #sitemap: /sitemap.xml #commonweal: /404.html #&lt;!--下面是对应的图标哦 --&gt; menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat warn: 在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的Font Awesome 图标名字） 的情况下，NexT 将会使用 作为图标。 设置头像打开../Hexo/_config.yml,搜索avatar 集成第三方服务 1.添加多说评论去多说创建一个站点，具体步骤如下：a. 登录后在首页选择 “我要安装”。b. 创建站点，填写站点相关信息。随便填，圈起来的部分要记住打开../Hexo/themes/next/_config.yml,搜索duoshuo_shortname并修改为如下：1duoshuo_shortname: iissnan-notes&lt;!-- 此处填写上图圈出来的部分,此写法作为例子 --&gt; c. 开启多说热评文章在../Hexo/themes/next/_config.yml中设置duoshuo_hotartical为trued. 多说评论修改登录多说后，在首页右上角点击“后台管理”，选择站点名称打开多说后台管理页面，选择“设置”下拉找到“自定义CSS”输入框，填写以下CSS样式，效果参考文章结尾评论样式。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*-------------访客底部----------------*/.ds-recent-visitors &#123; margin-bottom: 200px;&#125;@media (max-width: 768px) &#123; .ds-recent-visitors &#123; margin-bottom: 440px; &#125;&#125;/*-------------非圆角----------------*/#ds-reset .ds-rounded &#123; border-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-textarea-wrapper &#123; border-top-right-radius: 0px; border-top-left-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-post-button &#123; border-radius: 0px;&#125;.ds-post-self xmp &#123; word-wrap: break-word;&#125;/*-------------访客----------------*/#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/ border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/ -moz-transition: -moz-transform 0.4s ease-out;&#125;/*-------------访客悬浮在头像----------------*/#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123; box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); -webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); transform: rotateZ(360deg); /*图像旋转360度*/ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg);&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123; background: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*-------------隐藏版权----------------*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 2. 为Next添加文章阅读量功能 参考为NexT主题添加文章阅读量统计功能 3.添加搜索功能不巧，刚在一个多月前Swiftype搜索只对企业开放，Algolia摸索了好久总有bug，下面介绍我找到的搜索方法：a. 在../Hexo处右击鼠标打开Git Bash输入（目的是安装hexo-generator-searchdb）：1$ npm install hexo-generator-searchdb --save b.在../Hexo/_config.yml里面增下以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 4.背景效果 点击鼠标出现红心,添加love.js放在../hexo/themes/next/source/js/src文件目录下。然后在../hexo/themes/next/layout/_layout.swig末尾添加引用： 12 &lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 5.头像圆形旋转 把完整的sidebar-author.styl文件内容参考地址复制替换到..hexo/themes/next/source/css/_common/components/sidebar/sidebar-author.styl即可。 更多开发参考Next开发文档 注册Github并上传数据 a. 打开Github网站，注册账号, 然后点击Start a Project,注册仓库如下填写，注意Owner的名字和Pepository name中.github.io前面的要一致！(这里因为我已经注册仓库，所以会提示已经存在)，然后创建仓库即可 最后在../Hexo/_config.yml处拉到最后，写成如下: 12345 #swiftype_key: deploy: type: git repository: http://github.com/Superbsco/Superbsco.github.io.git branch: master warn: 注意只需要把那两个Superbsco改为注册时候填写的仓库名称即可 最后在../Hexo执行Git hash先执行hexo clean，然后重新部署执行hexo g，并且上传执行hexo d中途输入Github的账号密码即可上传成功，在浏览器打开“你的仓库名字”.github.io即可看到网页效果！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F12%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to my new blog! 下面附录一大堆文字测试效果； 我望着长城，常常不能自语。之前一直在学习html+css，偶尔查找资料发现了基于Hexo的博客，我一下子被这么美观的设计吸引了，原来有人可以把网页设计的这么棒，整个篇幅下来没有广告，很整洁，很清晰，主题明朗，阅读体验超级棒，于是想着搜索这个网站到底是怎么建立的，那么就找到了，原来这是一个台湾大学生tommy351用node.js开发的Hexo，Hexo是一个开源的静态博客生成器。对于建立个人网站来说，没有什么比博客更合适了，既然是开源的，那么我就疯狂谷歌百度查找资料，最终基于Hexo 3.2.2版本，使用Next主题写成了这个博客 谷歌百度查到的资料层出不穷，版本新旧都有，而且很简单的东西，有人非要写的那么复杂，让人看不懂，在综合了很多很多教程之后，遇到过很多很多问题，都是一个个的慢慢解决，比如头像旋转啊，添加facebook，微博啊之类的，最后的最后发现最基本的开发文档才是最靠谱的！！ 随便写下这个首篇博客暖暖场，下面附录一些基本插入代码的格式，加入标题的格式，方便以后查看~~ 格式标语Create a new post1hexo new "My New Post" More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
