<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[基数排序]]></title>
      <url>%2F2017%2F01%2F14%2Fshujujiegou%2F</url>
      <content type="text"><![CDATA[如果一片瓦尔登湖不能荡涤心灵，那就没办法了~ 前言数据结构实践任务，花了几个星期在网上找，都是不完全的版本，加入自己的理解写下能排数字和字母的基数排序~ 基数排序问题描述对输入的关键字序列进行链式基数排序，并分析算法复杂度。 任务要求1) 对输入的自然数关键字序列进行链式基数排序。2) 需排序的数据是英文单词，从文件中读取；按字典顺序排列，写文件保存。 测试数据输入自然数关键字序列：278，109，63，930，589，184，505，269，8，83。输入英文单词组成的文件，按字典排序并输出到文件中。 解释第一个自然数关键字排序直接在cmd窗口输入即可排序。第二个读取字母并排序之前需要在D盘中创建一个f1.txt文件，在里面输入10个长度小于等于9的单词，每输入一个单词换行。这里不管是自然数还是单词统一使用MSD优先排序（即从前往后对比）。具体排序思路参考严蔚敏的数据结构。 算法复杂度分析 代码 此代码在VS2015上正常运行~ #include &lt;iostream&gt; #include &lt;fstream&gt; //文件输入输出流 #include&lt;string&gt; using namespace std; //数字结构体 #define MAX_NUM_OF_KEY 8//关键字项数的最大值 #define RADIX 10//关键字基数，此时是十进制整数的基数 #define MAX_SPACE 10000 typedef int DataType; typedef struct { int data;//数据，如278 DataType keys[MAX_NUM_OF_KEY];//每个数据的所有关键字，278的2，7，8 int next; }SLCell; //静态链表的节点类型 typedef struct Sllist { SLCell *R; //静态链表的可利用空间，r[0]为头结点 int recnum; //静态链表的当前长度 int keynum; //当前数据的关键字个数 }Sllist, *SLList; //静态链表类型 typedef int ArrType[RADIX];//指针数组类型，声明两个指针数组，一个头指针，一个尾指针 //字母结构体 #define MaxLen 9 //单词的最大长度 #define Radix 27 //基数rd为27,分别对应' ','a',…'z' typedef char String[MaxLen + 1];//定义String为字符数组类型 typedef struct node { String word; //单词 struct node *next; //next指针 } LinkNode; //数字基数排序 void creatList(SLList &amp;SLL) //创建链表 { int key; int i = 1, j; cout &lt;&lt; "输入要进行排序的数字(输入0结束):" &lt;&lt; endl; cin &gt;&gt; key; while (key != 0) { SLL-&gt;R[i].data = key; for (j = 1; j &lt;= SLL-&gt;keynum; j++) { SLL-&gt;R[i].keys[j] = key % 10; key /= 10; } SLL-&gt;R[i - 1].next = i++; cin &gt;&gt; key; } SLL-&gt;recnum = i - 1; SLL-&gt;R[SLL-&gt;recnum].next = 0; } //打印输出 void print(SLList &amp;SLL) { for (int p = SLL-&gt;R[0].next; p; p = SLL-&gt;R[p].next) { cout &lt;&lt;"["&lt;&lt; SLL-&gt;R[p].data &lt;&lt;"]"&lt;&lt; " "; } cout &lt;&lt; endl; } //分配算法 void distribute(SLCell *R, int i, ArrType front, ArrType end) { //静态链表L的R域中记录已按(keys[0]...keys[i-1]有序)。 //本算法按第i个关键字keys[i]建立RADIX个子表，使同一子表中记录的keys[i]相同。 //front[0...RADIX-1]和end[0...RADIX-1]分别指向各子表中第一个和最后一个记录。 int j; for (int j = 0; j&lt;RADIX; ++j) front[j] = 0; //各子表初始化为空表 for (int p = R[0].next; p; p = R[p].next) { j = R[p].keys[i]; //映射第i个关键字 if (!front[j]) front[j] = p; //若front[j]为空，则把记录连接到front[j]的头指针上 else R[end[j]].next = p; //若front[j]的头指针已经连接过了，说明已j为关键字的数据已经有了， //这时把上一个以j为关键字的数据指向当前的这个数，即下标为p的数据 end[j] = p; //尾指针重新指到每次更新的数据上 } } //收集算法 void collect(SLCell *R, int i, ArrType front, ArrType end) { //本算法按keys[i]自小到大地将f[0...RADIX-1]所指各子表依次链接成为一个链表 int j; for (j = 0; !front[j]; j++); //找到第一个不为空的子表 R[0].next = front[j]; //重整静态链表 int k = end[j]; //k为当前子表的尾指针 while (j&lt;RADIX) { for (++j; j&lt;RADIX; j++) if (front[j]) //找下一个非空子表 { R[k].next = front[j]; //连接 k = end[j]; } } R[k].next = 0; //k指向最后一个非空子表的尾指针 } //字母基数排序 void DispWord(String R[], int n) //输出单词 { int i; string o[10]; ofstream fout("D:\\inf.txt"); //排序成功后，重新对排序写入inf.txt if (!fout) { cout &lt;&lt; "Fail to write to file.\n"; } for (i = 0; i &lt; n; i++) { cout &lt;&lt; "[" &lt;&lt; R[i] &lt;&lt; "]"; o[i] = R[i]; fout &lt;&lt; "["&lt;&lt;o[i]&lt;&lt;"]" &lt;&lt; endl; } cout &lt;&lt; endl; fout.close(); } void PreProcess(String R[], int n) //对单词进行预处理,用空格填充尾部至MaxLen长 { int i, j; for (i = 0; i&lt;n; i++) { if (strlen(R[i])&lt;MaxLen) { for (j = strlen(R[i]); j&lt;MaxLen; j++) R[i][j] = ' '; R[i][j] = '\0'; } } } void EndProcess(String R[], int n) //恢复处理,删除预处理时填充的尾部空格 { int i, j; for (i = 0; i&lt;n; i++) { for (j = MaxLen - 1; R[i][j] == ' '; j--); R[i][j + 1] = '\0'; } } void Distribute(String R[], LinkNode *head[], LinkNode *tail[], int j, int n) //按关键字的第j个分量进行分配,进入此过程时各队列一定为空 { int i, k; LinkNode *p; for (i = 0; i&lt;n; i++) //依次扫描R[i],将其入队 { if (R[i][j] == ' ') //空格时放入0号队列中,'a'时放入1号队列中,… k = 0; else k = R[i][j] - 'a' + 1; p = (LinkNode *)malloc(sizeof(LinkNode)); //创建新结点 strcpy_s(p-&gt;word, R[i]); p-&gt;next = NULL; if (head[k] == NULL) { head[k] = p; tail[k] = p; } else { tail[k]-&gt;next = p; tail[k] = p; } } } void Collect(String R[], LinkNode *head[]) //依次将各非空队列中的记录收集起来 { int k = 0, i; LinkNode *p; for (i = 0; i&lt;Radix; i++) for (p = head[i]; p != NULL; p = p-&gt;next) strcpy_s(R[k++], p-&gt;word); } void RadixSort(String R[], int n) //对R[0..n-1]进行基数排序 { LinkNode *head[Radix], *tail[Radix]; //定义Radix个队列 int i, j; int k = 1; for (i = MaxLen - 1; i &gt;= 0; i--) //从低位到高位做d趟箱排序 { for (j = 0; j&lt;Radix; j++) head[j] = tail[j] = NULL; //队列置空 Distribute(R, head, tail, i, n); //第i趟分配 Collect(R, head); //第i趟收集 cout &lt;&lt; "第" &lt;&lt; k &lt;&lt; "趟分配和收集:" &lt;&lt; endl; for (int m = 0; m &lt;10; m++) { cout&lt;&lt;"["&lt;&lt;R[m]&lt;&lt;"]"; } k++; cout &lt;&lt; endl; } } //主函数 int main() { SLList SLL; SLL = (SLList)malloc(MAX_SPACE * sizeof(Sllist)); SLL-&gt;R = (SLCell *)malloc(MAX_SPACE * sizeof(SLCell)); SLL-&gt;recnum = 0; SLL-&gt;keynum = 3; string R[10]; String c[10]; ifstream fopen("D:\\f1.txt");//读取D盘inf.txt文件 if (!fopen) { cout &lt;&lt; "fail to read the file.\n"; } while (!fopen.eof()) { //读取D盘写入的文件 for (int q = 0; q&lt;10; q++) { getline(fopen, R[q]); //读取第一行 strcpy_s(c[q],R[q].c_str()); } } fopen.close(); /*ofstream fout("D:\\inf.txt"); //排序成功后，重新对用户信息写入inf.txt if (!fout) { cout &lt;&lt; "Fail to write to file.\n"; } for (int o = 0; o &lt; 10; o++) { fout &lt;&lt; c[o] &lt;&lt; endl; } fout.close();*/ int k; while (1) { cout &lt;&lt; "*************基数排序程序***************" &lt;&lt; endl; cout &lt;&lt; "* 选择要执行的命令 *" &lt;&lt; endl; cout &lt;&lt; "* 1.输入自然数进行链式基数排序 *" &lt;&lt; endl; cout &lt;&lt; "* 2.从文件中读取字母,按字典顺序排列 *" &lt;&lt; endl; cout &lt;&lt; "* 3.退出程序 *" &lt;&lt; endl; cout &lt;&lt; "****************************************" &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; cin &gt;&gt; k; switch (k) { case 1: creatList(SLL); cout &lt;&lt; "排序前:" &lt;&lt; endl; print(SLL); ArrType front, end; for (int i = 1; i &lt;= SLL-&gt;keynum; i++) //按LSD法对各关键字进行分配和收集 { distribute(SLL-&gt;R, i, front, end); //第i趟分配 collect(SLL-&gt;R, i, front, end); //第i趟收集 cout &lt;&lt; "第" &lt;&lt; i &lt;&lt; "趟分配和收集:" &lt;&lt; endl; print(SLL); } cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; break; case 2: cout &lt;&lt; "从D:\\f1.txt中读取到的单词为：" &lt;&lt; endl; DispWord(c, 10); PreProcess(c, 10); cout &lt;&lt; "预处理后：" &lt;&lt; endl; DispWord(c, 10); RadixSort(c, 10); cout &lt;&lt; "排序结果：" &lt;&lt; endl; DispWord(c, 10); EndProcess(c, 10); cout &lt;&lt; "最终结果：" &lt;&lt; endl; DispWord(c, 10); cout &lt;&lt; "******排序后的结果已经成功写入D盘inf.txt!******"; cout &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl; break; case 3: exit(0); default: cout &lt;&lt; "请输入正确的数字！" &lt;&lt; endl; break; } } return 0; }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文件管理之文件系统设计]]></title>
      <url>%2F2017%2F01%2F14%2Fospassage%2F</url>
      <content type="text"><![CDATA[当夜幕降临时，在太阳以西，国境以南处，等候你的归来~ 前言这是操作系统课上的一个课后作业，操作系统考完后基本就忘记的差不多了，把这个实践代码在这里重新过一遍~ 文件管理之文件系统设计实验目的本实验的目的是使学生在学习文件系统原理的基础上，通过参考成熟的操作系统中文件系统的设计，实现一个简单的多用户文件系统，加深对文件系统的功能、内部结构包括逻辑结构以及物理结构的理解。 实验内容设计一个简单的二级文件系统。要求实现下列命令：12345login 用户登录dir 列文件目录create 创建文件delete 删除文件 &lt;!-- 列目录时要列出文件名、物理地址、文件长度。--&gt; 实验提示 1.首先设计文件系统的物理结构、模拟磁盘存储结构（目录与文件的组织方式）。 2.确定文件系统的数据结构：主目录、子目录及活动文件等。主目录和子目录都可以文件的形式存放于磁盘，这样便于查找和修改。 3.用户创建的文件，可以编号存储于模拟磁盘上。如file0，file1，file2，.…..并以编号作为物理地址，在目录中进行登记。 实验说明 可以参考现有的系统如FAT、NTFS或ext3等系统的结构。 同学在完成基本功能的基础上可以考虑对系统的扩展，如多级目录、文件的共享以及系统的优化，如目录查找算法的改进等。 实现代码 此代码在VS2015上正常运行~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#define MaxUser 100//定义最大MDF主目录文件#define MaxDisk 512*1024//模拟最大磁盘空间#define commandAmount 12//对文件操作的指令数//存储空间管理有关结构体和变量char disk[MaxDisk];//模拟512K的磁盘存储空间typedef struct distTable//磁盘块结构体&#123; int maxlength; int start; int useFlag; distTable *next;&#125;diskNode;diskNode *diskHead;struct fileTable//文件块结构体&#123; char fileName[10]; int strat;//文件在磁盘存储空间的起始地址 int length;//文件内容长度 int maxlength;//文件的最大长度 char fileKind[3];//文件的属性——读写方式 struct tm *timeinfo; bool openFlag;//判断是否有进程打开了该文件//fileTable *next;&#125;;//两级目录结构体typedef struct user_file_directory//用户文件目录文件UFD&#123; //char fileName[10]; fileTable *file; user_file_directory *next;&#125;UFD;//UFD *headFile;typedef struct master_file_directory//主文件目录MFD&#123; char userName[10]; char password[10]; UFD *user;&#125;MFD;MFD userTable[MaxUser];int used = 0; //定义MFD目录中用已有的用户数//文件管理void fileCreate(char fileName[], int length, char fileKind[]);//创建文件void fileDir(char UserName[]); //显示某一用户的所有文件void fileDel(char fileName[]); //删除文件int requestDist(int &amp;startPostion, int maxLength); //磁盘分配查询void initDisk(); //初始化磁盘void userCreate();//用户管理int login();int userID = -1;//用户登录的ID号，值为-1时表示没有用户登录int main()&#123; char order[commandAmount][10]; strcpy(order[1], "create"); strcpy(order[2], "del"); strcpy(order[3], "dir"); strcpy(order[0], "0"); char command[50], command_str1[15], command_str2[15], command_str3[15], command_str4[13]; int i, k, j; int length; initDisk(); //初始化磁盘 for (i = 0; i&lt;MaxUser; i++)//初始化用户UFD目录文件的头指针 &#123; userTable[i].user = (UFD *)malloc(sizeof(UFD)); userTable[i].user-&gt;next = NULL; &#125; while (1) &#123; printf("\n"); printf(" 1、Creat user\n"); printf(" 2、login\n"); printf("\n"); printf("Please chooce the function key:&gt;"); int choice; scanf("%d", &amp;choice); if (choice == 1) userCreate(); else if (choice == 2) userID = login(); else printf("您的输入有误，请重新选择\n"); while (userID != -1) &#123; fflush(stdin); gets_s(command); printf("———————————————————————————————————————\n"); printf(" create-创建 格式：create a1 1000 rw,将创建名为a1,长度为1000字节可读可写的文件\n"); printf(" del-删除 格式：del a1,将删除名为a1的文件\n"); printf(" dir-显示文件 格式：dir aaa,将显示aaa用户的所有文件\n"); printf(" exit-退出程序(输入exit时在后面加一个空格，否则退出异常)\n"); printf("————————————————————————————————————————\n"); printf("please imput your command:&gt;"); gets_s(command); int select; //command_str1字符串存储命令的操作类型 for (i = 0; command[i] != ' '&amp;&amp;command[i] != '\0'; i++) command_str1[i] = command[i]; k = i; command_str1[k] = '\0'; for (i = 0; i&lt;commandAmount; i++) &#123; if (!strcmp(command_str1, order[i])) &#123; select = i; break; &#125; &#125; if (i == commandAmount) &#123; printf("您输入的命令有误，请重新输入\n"); continue; &#125; //commmand_str2字符串存储文件名或用户名 for (i = k + 1, k = 0; command[i] != ' '&amp;&amp;command[i] != '\0'; i++, k++) command_str2[k] = command[i]; command_str2[k] = '\0'; k = i; switch (select) &#123; case 1:for (i = k + 1, k = 0; command[i] != ' '; i++, k++) command_str3[k] = command[i]; command_str3[k] = '\0'; k = i; j = 1; length = 0;//初始化文件长度 for (i = strlen(command_str3) - 1; i &gt;= 0; i--) //把字符串转换为十进制 &#123; length += (command_str3[i] - 48)*j; j *= 10; &#125; for (i = k + 1, k = 0; command[i] != ' '&amp;&amp;command[i] != '\0'; i++, k++) command_str4[k] = command[i]; command_str4[k] = '\0'; fileCreate(command_str2, length, command_str4); break; case 2:fileDel(command_str2); break; case 3:fileDir(command_str2); break; case 0:exit(1); default: break; &#125; &#125; &#125; return 0;&#125;void userCreate()&#123; char c; char userName[10]; int i; if (used&lt;MaxUser) &#123; printf("请输入用户名："); for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else userName[i] = c; printf("%c", c); &#125; userName[i] = '\0'; for (i = 0; i&lt;used; i++) &#123; if (!strcmp(userTable[i].userName, userName)) &#123; printf("\n"); printf("该用户名已存在,创建用户失败\n"); system("pause"); return; &#125; &#125; strcpy(userTable[used].userName, userName); printf("\n"); printf("请输入密码："); for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else userTable[used].password[i] = c; printf("*"); &#125; userTable[userID].password[i] = '\0'; printf("\n"); printf("创建用户成功\n"); used++; system("pause"); &#125; else &#123; printf("创建用户失败，用户已达到上限\n"); system("pause"); &#125; fflush(stdin);&#125;int login()&#123; char name[10], psw[10]; char c; int i, times; printf("请输入用户名:"); for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else name[i] = c; printf("%c", c); &#125; name[i] = '\0'; for (i = 0; i&lt;used; i++) &#123; if (!strcmp(userTable[i].userName, name)) break; &#125; if (i == used) &#123; printf("\n您输入的用户名不存在\n"); system("pause"); return -1; &#125; for (times = 0; times&lt;3; times++) &#123; memset(psw, '\0', sizeof(psw)); printf("\n请输入密码:"); /*for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else psw[i] = c; printf("*"); &#125; printf("\n");*/ int i = 0; while (psw[i]=_getch()) &#123; if (psw[i]!='\r') &#123; printf("*"); i++; &#125; else &#123; break; &#125; &#125; psw[i] = '\0'; printf("\n"); for (i = 0; i&lt;used; i++) &#123; if (!strcmp(psw, userTable[i].password)) &#123; printf("用户登录成功\n"); system("pause"); break; &#125; &#125; if (i == used) &#123; printf("\n您输入的密码错误，您还有%d次输入机会\n", 2 - times); if (times == 2) exit(0); &#125; else break; &#125; fflush(stdin); return i;&#125;void initDisk()&#123; diskHead = (diskNode *)malloc(sizeof(diskNode)); diskHead-&gt;maxlength = MaxDisk; diskHead-&gt;useFlag = 0; diskHead-&gt;start = 0; diskHead-&gt;next = NULL;&#125;int requestDist(int &amp;startPostion, int maxLength)&#123; int flag = 0; //标记是否分配成功 diskNode *p, *q, *temp; p = diskHead; while (p) &#123; if (p-&gt;useFlag == 0 &amp;&amp; p-&gt;maxlength&gt;maxLength) &#123; startPostion = p-&gt;start; q = (diskNode *)malloc(sizeof(diskNode)); q-&gt;start = p-&gt;start; q-&gt;maxlength = maxLength; q-&gt;useFlag = 1; q-&gt;next = NULL; diskHead-&gt;start = p-&gt;start + maxLength; diskHead-&gt;maxlength = p-&gt;maxlength - maxLength; flag = 1; temp = p; if (diskHead-&gt;next == NULL) diskHead-&gt;next = q; else &#123; while (temp-&gt;next) temp = temp-&gt;next; temp-&gt;next = q; &#125; break; &#125; p = p-&gt;next; &#125; return flag;&#125;void fileCreate(char fileName[], int length, char fileKind[])&#123; //int i,j; time_t rawtime; int startPos; UFD *fileNode, *p; for (p = userTable[userID].user-&gt;next; p != NULL; p = p-&gt;next) &#123; if (!strcmp(p-&gt;file-&gt;fileName, fileName)) &#123; printf("文件重名，创建文件失败\n"); system("pause"); return; &#125; &#125; if (requestDist(startPos, length)) &#123; fileNode = (UFD *)malloc(sizeof(UFD)); //这一步必不可少，因为fileNode里面的指针也需要申请地址，否则fileNode-&gt;file指向会出错 fileNode-&gt;file = (fileTable *)malloc(sizeof(fileTable)); strcpy(fileNode-&gt;file-&gt;fileName, fileName); strcpy(fileNode-&gt;file-&gt;fileKind, fileKind); fileNode-&gt;file-&gt;maxlength = length; fileNode-&gt;file-&gt;strat = startPos; fileNode-&gt;file-&gt;openFlag = false; time(&amp;rawtime); fileNode-&gt;file-&gt;timeinfo = localtime(&amp;rawtime); fileNode-&gt;next = NULL; if (userTable[userID].user-&gt;next == NULL) userTable[userID].user-&gt;next = fileNode; else &#123; p = userTable[userID].user-&gt;next; while (p-&gt;next) p = p-&gt;next; p-&gt;next = fileNode; &#125; printf("创建文件成功\n"); printf("按任意键继续..."); //system("pause"); &#125; else &#123; printf("磁盘空间已满或所创建文件超出磁盘空闲容量，磁盘空间分配失败\n"); printf("按任意键继续..."); //system("pause"); &#125;&#125;void freeDisk(int startPostion)&#123; diskNode *p; for (p = diskHead; p != NULL; p = p-&gt;next) &#123; if (p-&gt;start == startPostion) break; &#125; p-&gt;useFlag = false;&#125;void fileDel(char fileName[])&#123; UFD *p, *q, *temp; q = userTable[userID].user; p = q-&gt;next; while (p) &#123; if (!strcmp(p-&gt;file-&gt;fileName, fileName)) break; else &#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; if (p) &#123; if (p-&gt;file-&gt;openFlag != true) //先判断是否有进程打开该文件 &#123; temp = p; q-&gt;next = p-&gt;next; freeDisk(temp-&gt;file-&gt;strat);//磁盘空间回收 free(temp); printf("文件删除成功\n"); printf("按任意键继续..."); //system("pause"); &#125; else &#123; printf("该文件已被进程打开,删除失败\n"); printf("按任意键继续..."); //system("pause"); &#125; &#125; else &#123; printf("没有找到该文件,请检查输入的文件名是否正确\n"); printf("按任意键继续..."); //system("pause"); &#125;&#125;void fileDir(char userName[])&#123; UFD *p; int i, k; for (i = 0; i&lt;MaxUser; i++) &#123; if (!strcmp(userTable[i].userName, userName)) &#123; k = i; break; &#125; &#125; if (i == MaxUser) &#123; printf("没有找到该用户，请检查输入用户名是否正确\n"); printf("按任意键继续..."); //system("pause"); return; &#125; else &#123; p = userTable[k].user-&gt;next; printf("\n"); printf("文件名 文件长度 文件在磁盘的起始地址 文件类型 创建时间\n"); for (; p != NULL; p = p-&gt;next) printf("%s %d %d %s %s", p-&gt;file-&gt;fileName, p-&gt;file-&gt;maxlength, p-&gt;file-&gt;strat, p-&gt;file-&gt;fileKind, asctime(p-&gt;file-&gt;timeinfo)); printf("\n"); printf("按任意键继续..."); //system("pause"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记录Hexo+Github免费搭建个人博客]]></title>
      <url>%2F2017%2F01%2F13%2Fnew-article%2F</url>
      <content type="text"><![CDATA[不急，先上一首歌曲，然后慢慢记录~ 动机这几天一直在利用Hexo搭建自己的博客，对于hexo的强大能力感到赞叹，中途谷歌百度了很多教程，一路经历各种坎坷艰辛，而且别人的教程版本都很旧，在自己摸索下终于完成了现在这个博客，博客刚建立，文章少的可怜，就用来暖暖场吧~，也为了不使自己忘记，也因为一直有记录的习惯，算是个人笔记写一下这个博客的搭建记录吧~ 这个记录流程只适用于windows 准备工具1.Node.js2.Git 安装Hexo上面两个文件安装好之后，在你觉得合适的位置，建立一个文件夹（命名不要写中文！下面以该文件夹命名为Hexo为例），进入该文件夹，右击鼠标选择Git Bash,然后输入下列文字（目的是安装Hexo,$已经帮你打好,为了形象在此加入$）:1$ npm install hexo-cli -g 在本地搭建Hexo安装Hexo后，继续在当前 Git Bash里面按顺序执行以下命令(中途也许会看到warn提醒，可以不管)：123456$ npm install hexo --save$ hexo -v$ hexo init$ npm install$ hexo g$ hexo s 当你执行完hexo s后，你会看到 “INFO Hexo is running at http : //0.0.0.0:4000/.Press Ctrl+C to stop.”这句话这时候，不要关闭git bash，在高级浏览器（chorm，火狐，等）输入http://localhost:4000 你就可以看到你的博客了。 为你的博客更换主题hexo为我们提供了很多主题,如果你觉得初始主题已经不错了，那就不用更换了，下面以主题Next为例，继续记录~~在../Hexo下打开Git Bash 输入：1$ git clone https://github.com/iissnan/hexo-theme-next 这表示下载Next主题，等待主题下载完毕~~然后在打开../Hexo/_config.yml，建议是使用Notepad++,用Notepad++打开后ctrl+F弹出搜索框，输入关键字theme:，然后找到theme: 后大概是这样的1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 这时候把landscape改为:（如果手打记得冒号后面必须加一个空格！）1theme: next 然后在Git hash先执行hexo clean，然后执行hexo g，再执行hexo s，很快就能看到新主题的效果了~&gt;Next有三套主题选择，打开../Hexo/themes/next/_config.yml 搜索关键字Schemes:1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces #代表注释，如果去掉#就说明使用当前主题。下面以使用Next.Mist主题为例.. 配置个人博客打开../Hexo/_config.yml1234567# Sitetitle: “你的博客名字”subtitle: “副标题”description: “描述”author: “作者”language: zh-Hans“这里的设置请参考下图”timezone: 打开../Hexo/themes/next/_config.yml 1234567891011121314151617181920menu: home: / archives: /archives categories: /categories tags: /tags about: /about #sitemap: /sitemap.xml #commonweal: /404.html #&lt;!--下面是对应的图标哦 --&gt; menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat warn: 在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的Font Awesome 图标名字） 的情况下，NexT 将会使用 作为图标。 设置头像打开../Hexo/_config.yml,搜索avatar 集成第三方服务 1.添加多说评论去多说创建一个站点，具体步骤如下：a. 登录后在首页选择 “我要安装”。b. 创建站点，填写站点相关信息。随便填，圈起来的部分要记住打开../Hexo/themes/next/_config.yml,搜索duoshuo_shortname并修改为如下：1duoshuo_shortname: iissnan-notes&lt;!-- 此处填写上图圈出来的部分,此写法作为例子 --&gt; c. 开启多说热评文章在../Hexo/themes/next/_config.yml中设置duoshuo_hotartical为trued. 多说评论修改登录多说后，在首页右上角点击“后台管理”，选择站点名称打开多说后台管理页面，选择“设置”下拉找到“自定义CSS”输入框，填写以下CSS样式，效果参考文章结尾评论样式。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*-------------访客底部----------------*/.ds-recent-visitors &#123; margin-bottom: 200px;&#125;@media (max-width: 768px) &#123; .ds-recent-visitors &#123; margin-bottom: 440px; &#125;&#125;/*-------------非圆角----------------*/#ds-reset .ds-rounded &#123; border-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-textarea-wrapper &#123; border-top-right-radius: 0px; border-top-left-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-post-button &#123; border-radius: 0px;&#125;.ds-post-self xmp &#123; word-wrap: break-word;&#125;/*-------------访客----------------*/#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/ border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/ -moz-transition: -moz-transform 0.4s ease-out;&#125;/*-------------访客悬浮在头像----------------*/#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123; box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); -webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); transform: rotateZ(360deg); /*图像旋转360度*/ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg);&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123; background: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*-------------隐藏版权----------------*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 2. 为Next添加文章阅读量功能 参考为NexT主题添加文章阅读量统计功能 3.添加搜索功能不巧，刚在一个多月前Swiftype搜索只对企业开放，Algolia摸索了好久总有bug，下面介绍我找到的搜索方法：a. 在../Hexo处右击鼠标打开Git Bash输入（目的是安装hexo-generator-searchdb）：1$ npm install hexo-generator-searchdb --save b.在../Hexo/_config.yml里面增下以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 4.背景效果 点击鼠标出现红心,添加love.js放在../hexo/themes/next/source/js/src文件目录下。然后在../hexo/themes/next/layout/_layout.swig末尾添加引用： 12 &lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 5.头像圆形旋转 把完整的sidebar-author.styl文件内容参考地址复制替换到..hexo/themes/next/source/css/_common/components/sidebar/sidebar-author.styl即可。 更多开发参考Next开发文档 注册Github并上传数据 a. 打开Github网站，注册账号, 然后点击Start a Project,注册仓库如下填写，注意Owner的名字和Pepository name中.github.io前面的要一致！(这里因为我已经注册仓库，所以会提示已经存在)，然后创建仓库即可 最后在../Hexo/_config.yml处拉到最后，写成如下: 12345 #swiftype_key: deploy: type: git repository: http://github.com/Superbsco/Superbsco.github.io.git branch: master warn: 注意只需要把那两个Superbsco改为注册时候填写的仓库名称即可 最后在../Hexo执行Git hash先执行hexo clean，然后重新部署执行hexo g，并且上传执行hexo d中途输入Github的账号密码即可上传成功，在浏览器打开“你的仓库名字”.github.io即可看到网页效果！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F12%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to my new blog! 下面附录一大堆文字测试效果； 我望着长城，常常不能自语。之前一直在学习html+css，偶尔查找资料发现了基于Hexo的博客，我一下子被这么美观的设计吸引了，原来有人可以把网页设计的这么棒，整个篇幅下来没有广告，很整洁，很清晰，主题明朗，阅读体验超级棒，于是想着搜索这个网站到底是怎么建立的，那么就找到了，原来这是一个台湾大学生tommy351用node.js开发的Hexo，Hexo是一个开源的静态博客生成器。对于建立个人网站来说，没有什么比博客更合适了，既然是开源的，那么我就疯狂谷歌百度查找资料，最终基于Hexo 3.2.2版本，使用Next主题写成了这个博客 谷歌百度查到的资料层出不穷，版本新旧都有，而且很简单的东西，有人非要写的那么复杂，让人看不懂，在综合了很多很多教程之后，遇到过很多很多问题，都是一个个的慢慢解决，比如头像旋转啊，添加facebook，微博啊之类的，最后的最后发现最基本的开发文档才是最靠谱的！！ 随便写下这个首篇博客暖暖场，下面附录一些基本插入代码的格式，加入标题的格式，方便以后查看~~ 格式标语Create a new post1hexo new "My New Post" More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
