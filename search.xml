<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[操作系统实践之文件管理之文件系统设计]]></title>
      <url>%2F2017%2F01%2F14%2Fospassage%2F</url>
      <content type="text"><![CDATA[当夜幕降临时，在太阳以西，国境以南处，等候你的归来~ 前言这是操作系统课上的一个课后作业，操作系统考完后基本就忘记的差不多了，把这个实践代码在这里重新过一遍~ 文件管理之文件系统设计实验目的本实验的目的是使学生在学习文件系统原理的基础上，通过参考成熟的操作系统中文件系统的设计，实现一个简单的多用户文件系统，加深对文件系统的功能、内部结构包括逻辑结构以及物理结构的理解。 实验内容设计一个简单的二级文件系统。要求实现下列命令：12345login 用户登录dir 列文件目录create 创建文件delete 删除文件 &lt;!-- 列目录时要列出文件名、物理地址、文件长度。--&gt; 实验提示 1.首先设计文件系统的物理结构、模拟磁盘存储结构（目录与文件的组织方式）。 2.确定文件系统的数据结构：主目录、子目录及活动文件等。主目录和子目录都可以文件的形式存放于磁盘，这样便于查找和修改。 3.用户创建的文件，可以编号存储于模拟磁盘上。如file0，file1，file2，.…..并以编号作为物理地址，在目录中进行登记。 实验说明 可以参考现有的系统如FAT、NTFS或ext3等系统的结构。 同学在完成基本功能的基础上可以考虑对系统的扩展，如多级目录、文件的共享以及系统的优化，如目录查找算法的改进等。 实现代码 此代码在VS2015上正常运行~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;conio.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#define MaxUser 100//定义最大MDF主目录文件#define MaxDisk 512*1024//模拟最大磁盘空间#define commandAmount 12//对文件操作的指令数//存储空间管理有关结构体和变量char disk[MaxDisk];//模拟512K的磁盘存储空间typedef struct distTable//磁盘块结构体&#123; int maxlength; int start; int useFlag; distTable *next;&#125;diskNode;diskNode *diskHead;struct fileTable//文件块结构体&#123; char fileName[10]; int strat;//文件在磁盘存储空间的起始地址 int length;//文件内容长度 int maxlength;//文件的最大长度 char fileKind[3];//文件的属性——读写方式 struct tm *timeinfo; bool openFlag;//判断是否有进程打开了该文件//fileTable *next;&#125;;//两级目录结构体typedef struct user_file_directory//用户文件目录文件UFD&#123; //char fileName[10]; fileTable *file; user_file_directory *next;&#125;UFD;//UFD *headFile;typedef struct master_file_directory//主文件目录MFD&#123; char userName[10]; char password[10]; UFD *user;&#125;MFD;MFD userTable[MaxUser];int used = 0; //定义MFD目录中用已有的用户数//文件管理void fileCreate(char fileName[], int length, char fileKind[]);//创建文件void fileDir(char UserName[]); //显示某一用户的所有文件void fileDel(char fileName[]); //删除文件int requestDist(int &amp;startPostion, int maxLength); //磁盘分配查询void initDisk(); //初始化磁盘void userCreate();//用户管理int login();int userID = -1;//用户登录的ID号，值为-1时表示没有用户登录int main()&#123; char order[commandAmount][10]; strcpy(order[1], "create"); strcpy(order[2], "del"); strcpy(order[3], "dir"); strcpy(order[0], "0"); char command[50], command_str1[15], command_str2[15], command_str3[15], command_str4[13]; int i, k, j; int length; initDisk(); //初始化磁盘 for (i = 0; i&lt;MaxUser; i++)//初始化用户UFD目录文件的头指针 &#123; userTable[i].user = (UFD *)malloc(sizeof(UFD)); userTable[i].user-&gt;next = NULL; &#125; while (1) &#123; printf("\n"); printf(" 1、Creat user\n"); printf(" 2、login\n"); printf("\n"); printf("Please chooce the function key:&gt;"); int choice; scanf("%d", &amp;choice); if (choice == 1) userCreate(); else if (choice == 2) userID = login(); else printf("您的输入有误，请重新选择\n"); while (userID != -1) &#123; fflush(stdin); gets_s(command); printf("———————————————————————————————————————\n"); printf(" create-创建 格式：create a1 1000 rw,将创建名为a1,长度为1000字节可读可写的文件\n"); printf(" del-删除 格式：del a1,将删除名为a1的文件\n"); printf(" dir-显示文件 格式：dir aaa,将显示aaa用户的所有文件\n"); printf(" exit-退出程序(输入exit时在后面加一个空格，否则退出异常)\n"); printf("————————————————————————————————————————\n"); printf("please imput your command:&gt;"); gets_s(command); int select; //command_str1字符串存储命令的操作类型 for (i = 0; command[i] != ' '&amp;&amp;command[i] != '\0'; i++) command_str1[i] = command[i]; k = i; command_str1[k] = '\0'; for (i = 0; i&lt;commandAmount; i++) &#123; if (!strcmp(command_str1, order[i])) &#123; select = i; break; &#125; &#125; if (i == commandAmount) &#123; printf("您输入的命令有误，请重新输入\n"); continue; &#125; //commmand_str2字符串存储文件名或用户名 for (i = k + 1, k = 0; command[i] != ' '&amp;&amp;command[i] != '\0'; i++, k++) command_str2[k] = command[i]; command_str2[k] = '\0'; k = i; switch (select) &#123; case 1:for (i = k + 1, k = 0; command[i] != ' '; i++, k++) command_str3[k] = command[i]; command_str3[k] = '\0'; k = i; j = 1; length = 0;//初始化文件长度 for (i = strlen(command_str3) - 1; i &gt;= 0; i--) //把字符串转换为十进制 &#123; length += (command_str3[i] - 48)*j; j *= 10; &#125; for (i = k + 1, k = 0; command[i] != ' '&amp;&amp;command[i] != '\0'; i++, k++) command_str4[k] = command[i]; command_str4[k] = '\0'; fileCreate(command_str2, length, command_str4); break; case 2:fileDel(command_str2); break; case 3:fileDir(command_str2); break; case 0:exit(1); default: break; &#125; &#125; &#125; return 0;&#125;void userCreate()&#123; char c; char userName[10]; int i; if (used&lt;MaxUser) &#123; printf("请输入用户名："); for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else userName[i] = c; printf("%c", c); &#125; userName[i] = '\0'; for (i = 0; i&lt;used; i++) &#123; if (!strcmp(userTable[i].userName, userName)) &#123; printf("\n"); printf("该用户名已存在,创建用户失败\n"); system("pause"); return; &#125; &#125; strcpy(userTable[used].userName, userName); printf("\n"); printf("请输入密码："); for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else userTable[used].password[i] = c; printf("*"); &#125; userTable[userID].password[i] = '\0'; printf("\n"); printf("创建用户成功\n"); used++; system("pause"); &#125; else &#123; printf("创建用户失败，用户已达到上限\n"); system("pause"); &#125; fflush(stdin);&#125;int login()&#123; char name[10], psw[10]; char c; int i, times; printf("请输入用户名:"); for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else name[i] = c; printf("%c", c); &#125; name[i] = '\0'; for (i = 0; i&lt;used; i++) &#123; if (!strcmp(userTable[i].userName, name)) break; &#125; if (i == used) &#123; printf("\n您输入的用户名不存在\n"); system("pause"); return -1; &#125; for (times = 0; times&lt;3; times++) &#123; memset(psw, '\0', sizeof(psw)); printf("\n请输入密码:"); /*for (i = 0; c = getch(); i++) &#123; if (c == 13) break; else psw[i] = c; printf("*"); &#125; printf("\n");*/ int i = 0; while (psw[i]=_getch()) &#123; if (psw[i]!='\r') &#123; printf("*"); i++; &#125; else &#123; break; &#125; &#125; psw[i] = '\0'; printf("\n"); for (i = 0; i&lt;used; i++) &#123; if (!strcmp(psw, userTable[i].password)) &#123; printf("用户登录成功\n"); system("pause"); break; &#125; &#125; if (i == used) &#123; printf("\n您输入的密码错误，您还有%d次输入机会\n", 2 - times); if (times == 2) exit(0); &#125; else break; &#125; fflush(stdin); return i;&#125;void initDisk()&#123; diskHead = (diskNode *)malloc(sizeof(diskNode)); diskHead-&gt;maxlength = MaxDisk; diskHead-&gt;useFlag = 0; diskHead-&gt;start = 0; diskHead-&gt;next = NULL;&#125;int requestDist(int &amp;startPostion, int maxLength)&#123; int flag = 0; //标记是否分配成功 diskNode *p, *q, *temp; p = diskHead; while (p) &#123; if (p-&gt;useFlag == 0 &amp;&amp; p-&gt;maxlength&gt;maxLength) &#123; startPostion = p-&gt;start; q = (diskNode *)malloc(sizeof(diskNode)); q-&gt;start = p-&gt;start; q-&gt;maxlength = maxLength; q-&gt;useFlag = 1; q-&gt;next = NULL; diskHead-&gt;start = p-&gt;start + maxLength; diskHead-&gt;maxlength = p-&gt;maxlength - maxLength; flag = 1; temp = p; if (diskHead-&gt;next == NULL) diskHead-&gt;next = q; else &#123; while (temp-&gt;next) temp = temp-&gt;next; temp-&gt;next = q; &#125; break; &#125; p = p-&gt;next; &#125; return flag;&#125;void fileCreate(char fileName[], int length, char fileKind[])&#123; //int i,j; time_t rawtime; int startPos; UFD *fileNode, *p; for (p = userTable[userID].user-&gt;next; p != NULL; p = p-&gt;next) &#123; if (!strcmp(p-&gt;file-&gt;fileName, fileName)) &#123; printf("文件重名，创建文件失败\n"); system("pause"); return; &#125; &#125; if (requestDist(startPos, length)) &#123; fileNode = (UFD *)malloc(sizeof(UFD)); //这一步必不可少，因为fileNode里面的指针也需要申请地址，否则fileNode-&gt;file指向会出错 fileNode-&gt;file = (fileTable *)malloc(sizeof(fileTable)); strcpy(fileNode-&gt;file-&gt;fileName, fileName); strcpy(fileNode-&gt;file-&gt;fileKind, fileKind); fileNode-&gt;file-&gt;maxlength = length; fileNode-&gt;file-&gt;strat = startPos; fileNode-&gt;file-&gt;openFlag = false; time(&amp;rawtime); fileNode-&gt;file-&gt;timeinfo = localtime(&amp;rawtime); fileNode-&gt;next = NULL; if (userTable[userID].user-&gt;next == NULL) userTable[userID].user-&gt;next = fileNode; else &#123; p = userTable[userID].user-&gt;next; while (p-&gt;next) p = p-&gt;next; p-&gt;next = fileNode; &#125; printf("创建文件成功\n"); printf("按任意键继续..."); //system("pause"); &#125; else &#123; printf("磁盘空间已满或所创建文件超出磁盘空闲容量，磁盘空间分配失败\n"); printf("按任意键继续..."); //system("pause"); &#125;&#125;void freeDisk(int startPostion)&#123; diskNode *p; for (p = diskHead; p != NULL; p = p-&gt;next) &#123; if (p-&gt;start == startPostion) break; &#125; p-&gt;useFlag = false;&#125;void fileDel(char fileName[])&#123; UFD *p, *q, *temp; q = userTable[userID].user; p = q-&gt;next; while (p) &#123; if (!strcmp(p-&gt;file-&gt;fileName, fileName)) break; else &#123; p = p-&gt;next; q = q-&gt;next; &#125; &#125; if (p) &#123; if (p-&gt;file-&gt;openFlag != true) //先判断是否有进程打开该文件 &#123; temp = p; q-&gt;next = p-&gt;next; freeDisk(temp-&gt;file-&gt;strat);//磁盘空间回收 free(temp); printf("文件删除成功\n"); printf("按任意键继续..."); //system("pause"); &#125; else &#123; printf("该文件已被进程打开,删除失败\n"); printf("按任意键继续..."); //system("pause"); &#125; &#125; else &#123; printf("没有找到该文件,请检查输入的文件名是否正确\n"); printf("按任意键继续..."); //system("pause"); &#125;&#125;void fileDir(char userName[])&#123; UFD *p; int i, k; for (i = 0; i&lt;MaxUser; i++) &#123; if (!strcmp(userTable[i].userName, userName)) &#123; k = i; break; &#125; &#125; if (i == MaxUser) &#123; printf("没有找到该用户，请检查输入用户名是否正确\n"); printf("按任意键继续..."); //system("pause"); return; &#125; else &#123; p = userTable[k].user-&gt;next; printf("\n"); printf("文件名 文件长度 文件在磁盘的起始地址 文件类型 创建时间\n"); for (; p != NULL; p = p-&gt;next) printf("%s %d %d %s %s", p-&gt;file-&gt;fileName, p-&gt;file-&gt;maxlength, p-&gt;file-&gt;strat, p-&gt;file-&gt;fileKind, asctime(p-&gt;file-&gt;timeinfo)); printf("\n"); printf("按任意键继续..."); //system("pause"); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记录Hexo+Github免费搭建个人博客]]></title>
      <url>%2F2017%2F01%2F13%2Fnew-article%2F</url>
      <content type="text"><![CDATA[不急，先上一首歌曲，然后慢慢记录~ 动机这几天一直在利用Hexo搭建自己的博客，对于hexo的强大能力感到赞叹，中途谷歌百度了很多教程，一路经历各种坎坷艰辛，而且别人的教程版本都很旧，在自己摸索下终于完成了现在这个博客，博客刚建立，文章少的可怜，就用来暖暖场吧~，也为了不使自己忘记，也因为一直有记录的习惯，算是个人笔记写一下这个博客的搭建记录吧~ 这个记录流程只适用于windows 准备工具1.Node.js2.Git 安装Hexo上面两个文件安装好之后，在你觉得合适的位置，建立一个文件夹（命名不要写中文！下面以该文件夹命名为Hexo为例），进入该文件夹，右击鼠标选择Git Bash,然后输入下列文字（目的是安装Hexo,$已经帮你打好,为了形象在此加入$）:1$ npm install hexo-cli -g 在本地搭建Hexo安装Hexo后，继续在当前 Git Bash里面按顺序执行以下命令(中途也许会看到warn提醒，可以不管)：123456$ npm install hexo --save$ hexo -v$ hexo init$ npm install$ hexo g$ hexo s 当你执行完hexo s后，你会看到 “INFO Hexo is running at http : //0.0.0.0:4000/.Press Ctrl+C to stop.”这句话这时候，不要关闭git bash，在高级浏览器（chorm，火狐，等）输入http://localhost:4000 你就可以看到你的博客了。 为你的博客更换主题hexo为我们提供了很多主题,如果你觉得初始主题已经不错了，那就不用更换了，下面以主题Next为例，继续记录~~在../Hexo下打开Git Bash 输入：1$ git clone https://github.com/iissnan/hexo-theme-next 这表示下载Next主题，等待主题下载完毕~~然后在打开../Hexo/_config.yml，建议是使用Notepad++,用Notepad++打开后ctrl+F弹出搜索框，输入关键字theme:，然后找到theme: 后大概是这样的1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 这时候把landscape改为:（如果手打记得冒号后面必须加一个空格！）1theme: next 然后在Git hash先执行hexo clean，然后执行hexo g，再执行hexo s，很快就能看到新主题的效果了~&gt;Next有三套主题选择，打开../Hexo/themes/next/_config.yml 搜索关键字Schemes:1234# Schemes#scheme: Musescheme: Mist#scheme: Pisces #代表注释，如果去掉#就说明使用当前主题。下面以使用Next.Mist主题为例.. 配置个人博客打开../Hexo/_config.yml1234567# Sitetitle: “你的博客名字”subtitle: “副标题”description: “描述”author: “作者”language: zh-Hans“这里的设置请参考下图”timezone: 打开../Hexo/themes/next/_config.yml 1234567891011121314151617181920menu: home: / archives: /archives categories: /categories tags: /tags about: /about #sitemap: /sitemap.xml #commonweal: /404.html #&lt;!--下面是对应的图标哦 --&gt; menu_icons: enable: true #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome home: home about: user categories: th schedule: calendar tags: tags archives: archive sitemap: sitemap commonweal: heartbeat warn: 在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的Font Awesome 图标名字） 的情况下，NexT 将会使用 作为图标。 设置头像打开../Hexo/_config.yml,搜索avatar 集成第三方服务 1.添加多说评论去多说创建一个站点，具体步骤如下：a. 登录后在首页选择 “我要安装”。b. 创建站点，填写站点相关信息。随便填，圈起来的部分要记住打开../Hexo/themes/next/_config.yml,搜索duoshuo_shortname并修改为如下：1duoshuo_shortname: iissnan-notes&lt;!-- 此处填写上图圈出来的部分,此写法作为例子 --&gt; c. 开启多说热评文章在../Hexo/themes/next/_config.yml中设置duoshuo_hotartical为trued. 多说评论修改登录多说后，在首页右上角点击“后台管理”，选择站点名称打开多说后台管理页面，选择“设置”下拉找到“自定义CSS”输入框，填写以下CSS样式，效果参考文章结尾评论样式。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*-------------访客底部----------------*/.ds-recent-visitors &#123; margin-bottom: 200px;&#125;@media (max-width: 768px) &#123; .ds-recent-visitors &#123; margin-bottom: 440px; &#125;&#125;/*-------------非圆角----------------*/#ds-reset .ds-rounded &#123; border-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-textarea-wrapper &#123; border-top-right-radius: 0px; border-top-left-radius: 0px;&#125;.theme-next #ds-thread #ds-reset .ds-post-button &#123; border-radius: 0px;&#125;.ds-post-self xmp &#123; word-wrap: break-word;&#125;/*-------------访客----------------*/#ds-reset .ds-avatar img,#ds-recent-visitors .ds-avatar img &#123; width: 54px; height: 54px; /*设置图像的长和宽，这里要根据自己的评论框情况更改*/ border-radius: 27px; /*设置图像圆角效果,在这里我直接设置了超过width/2的像素，即为圆形了*/ -webkit-border-radius: 27px; /*圆角效果：兼容webkit浏览器*/ -moz-border-radius: 27px; box-shadow: inset 0 -1px 0 #3333sf; /*设置图像阴影效果*/ -webkit-box-shadow: inset 0 -1px 0 #3333sf; -webkit-transition: 0.4s; -webkit-transition: -webkit-transform 0.4s ease-out; transition: transform 0.4s ease-out; /*变化时间设置为0.4秒(变化动作即为下面的图像旋转360读）*/ -moz-transition: -moz-transform 0.4s ease-out;&#125;/*-------------访客悬浮在头像----------------*/#ds-reset .ds-avatar img:hover,#ds-recent-visitors .ds-avatar img:hover &#123; box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); -webkit-box-shadow: 0 0 10px #fff;rgba(255, 255, 255, .6), inset 0 0 20 px rgba(255, 255, 255, 1); transform: rotateZ(360deg); /*图像旋转360度*/ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg);&#125;#ds-thread #ds-reset .ds-textarea-wrapper textarea &#123; background: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;&#125;#ds-recent-visitors .ds-avatar &#123; float: left&#125;/*-------------隐藏版权----------------*/#ds-thread #ds-reset .ds-powered-by &#123; display: none;&#125; 2. 为Next添加文章阅读量功能 参考为NexT主题添加文章阅读量统计功能 3.添加搜索功能不巧，刚在一个多月前Swiftype搜索只对企业开放，Algolia摸索了好久总有bug，下面介绍我找到的搜索方法：a. 在../Hexo处右击鼠标打开Git Bash输入（目的是安装hexo-generator-searchdb）：1$ npm install hexo-generator-searchdb --save b.在../Hexo/_config.yml里面增下以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 4.背景效果 点击鼠标出现红心,添加love.js放在../hexo/themes/next/source/js/src文件目录下。然后在../hexo/themes/next/layout/_layout.swig末尾添加引用： 12 &lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt; 5.头像圆形旋转 把完整的sidebar-author.styl文件内容参考地址复制替换到..hexo/themes/next/source/css/_common/components/sidebar/sidebar-author.styl即可。 更多开发参考Next开发文档 注册Github并上传数据 a. 打开Github网站，注册账号, 然后点击Start a Project,注册仓库如下填写，注意Owner的名字和Pepository name中.github.io前面的要一致！(这里因为我已经注册仓库，所以会提示已经存在)，然后创建仓库即可 最后在../Hexo/_config.yml处拉到最后，写成如下: 12345 #swiftype_key: deploy: type: git repository: http://github.com/Superbsco/Superbsco.github.io.git branch: master warn: 注意只需要把那两个Superbsco改为注册时候填写的仓库名称即可 最后在../Hexo执行Git hash先执行hexo clean，然后重新部署执行hexo g，并且上传执行hexo d中途输入Github的账号密码即可上传成功，在浏览器打开“你的仓库名字”.github.io即可看到网页效果！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F01%2F12%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to my new blog! 下面附录一大堆文字测试效果； 我望着长城，常常不能自语。之前一直在学习html+css，偶尔查找资料发现了基于Hexo的博客，我一下子被这么美观的设计吸引了，原来有人可以把网页设计的这么棒，整个篇幅下来没有广告，很整洁，很清晰，主题明朗，阅读体验超级棒，于是想着搜索这个网站到底是怎么建立的，那么就找到了，原来这是一个台湾大学生tommy351用node.js开发的Hexo，Hexo是一个开源的静态博客生成器。对于建立个人网站来说，没有什么比博客更合适了，既然是开源的，那么我就疯狂谷歌百度查找资料，最终基于Hexo 3.2.2版本，使用Next主题写成了这个博客 谷歌百度查到的资料层出不穷，版本新旧都有，而且很简单的东西，有人非要写的那么复杂，让人看不懂，在综合了很多很多教程之后，遇到过很多很多问题，都是一个个的慢慢解决，比如头像旋转啊，添加facebook，微博啊之类的，最后的最后发现最基本的开发文档才是最靠谱的！！ 随便写下这个首篇博客暖暖场，下面附录一些基本插入代码的格式，加入标题的格式，方便以后查看~~ 格式标语Create a new post1hexo new "My New Post" More info: Writing Run server1hexo server More info: Server Generate static files1hexo generate More info: Generating Deploy to remote sites1hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
